#include <Eigen/Dense>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <chrono>
#include <vector>
#include <complex>
#include <cuda_runtime.h>
#include <string>
#include "test_config.h"  // Generated by CMake
#include "dof/affine_dof.hpp"
#include "geometry/packing.hpp"
#include "geometry/geometry_helpers.hpp"
#include "geometry/geometry.hpp"
#include "compute_intersection_volume.hpp"
#include "computation_flags.hpp"
#include "quadrature/lebedev_io.hpp"
#include "quadrature/kgrid.hpp"
#include "form_factor_helpers.hpp"

using namespace PoIntInt;

// Helper function to get the default Lebedev file path
std::string get_default_lebedev_path() {
#ifdef POINTINT_SOURCE_DIR
  std::string source_dir = POINTINT_SOURCE_DIR;
  // Convert to string and handle path separators
  // Use forward slashes (work on both Windows and Unix)
  std::string path = source_dir;
  // Replace backslashes with forward slashes for cross-platform compatibility
  for (size_t i = 0; i < path.length(); ++i) {
    if (path[i] == '\\') {
      path[i] = '/';
    }
  }
  return path + "/data/lebedev/lebedev_003.txt";
#else
  // Fallback if macro not defined
  return "data/lebedev/lebedev_131.txt";
#endif
}

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ============================================================================
// Helper Functions
// ============================================================================

// Compute gradient of intersection volume using finite differencing (GPU version)
Eigen::VectorXd compute_intersection_volume_gradient_finite_diff(
  const Geometry& geom1,
  const Geometry& geom2,
  const std::shared_ptr<DoFParameterization>& dof1,
  const std::shared_ptr<DoFParameterization>& dof2,
  const Eigen::VectorXd& dofs1,
  const Eigen::VectorXd& dofs2,
  const KGrid& kgrid,
  int which_geometry,  // 1 for geom1, 2 for geom2
  double eps = 1e-2)
{
  int n_dofs = (which_geometry == 1) ? dof1->num_dofs() : dof2->num_dofs();
  Eigen::VectorXd grad(n_dofs);
  
  // Note: We no longer use apply() - the unified interface works directly with reference geometry + DoFs
  
  for (int i = 0; i < n_dofs; ++i) {
    // 5-point finite difference for better accuracy
    // Create fresh copies for each perturbation to avoid accumulation errors
    Eigen::VectorXd dofs1_p2 = dofs1;
    Eigen::VectorXd dofs2_p2 = dofs2;
    Eigen::VectorXd dofs1_p1 = dofs1;
    Eigen::VectorXd dofs2_p1 = dofs2;
    Eigen::VectorXd dofs1_m1 = dofs1;
    Eigen::VectorXd dofs2_m1 = dofs2;
    Eigen::VectorXd dofs1_m2 = dofs1;
    Eigen::VectorXd dofs2_m2 = dofs2;
    
    // Set up perturbations
    if (which_geometry == 1) {
      dofs1_p2(i) += 2.0 * eps;
      dofs1_p1(i) += eps;
      dofs1_m1(i) -= eps;
      dofs1_m2(i) -= 2.0 * eps;
    } else {
      dofs2_p2(i) += 2.0 * eps;
      dofs2_p1(i) += eps;
      dofs2_m1(i) -= eps;
      dofs2_m2(i) -= 2.0 * eps;
    }
    
    // Compute volumes at perturbed DoFs using unified interface
    // Use original geometries with perturbed DoFs (no apply() needed)
    double vol_p2 = compute_intersection_volume_cuda(geom1, geom2, dof1, dof2, dofs1_p2, dofs2_p2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_p1 = compute_intersection_volume_cuda(geom1, geom2, dof1, dof2, dofs1_p1, dofs2_p1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m1 = compute_intersection_volume_cuda(geom1, geom2, dof1, dof2, dofs1_m1, dofs2_m1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m2 = compute_intersection_volume_cuda(geom1, geom2, dof1, dof2, dofs1_m2, dofs2_m2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    // 5-point finite difference: (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)) / (12h)
    grad(i) = (-vol_p2 + 8.0 * vol_p1 - 8.0 * vol_m1 + vol_m2) / (12.0 * eps);
  }
  
  return grad;
}

// ============================================================================
// Triangle Mesh Tests
// ============================================================================

// ============================================================================
// Phase 1: Test A(k) computation
// ============================================================================

bool test_phase1_Ak_computation() {
  std::cout << "\n=== Phase 1 Test: A(k) Computation ===" << std::endl;
  
  // Create unit cube mesh
  Eigen::MatrixXd V;
  Eigen::MatrixXi F;
  create_unit_cube_mesh(V, F);
  auto geom = make_triangle_mesh(V, F);
  
  // Create AffineDoF with identity transformation
  auto affine_dof = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.1, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(0.0, 0.0, 2.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 1.0),
  };
  
  double max_error_cpu = 0.0;
  double max_error_analytical = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& k : test_k_vectors) {
    // Compute A(k) using CUDA
    std::complex<double> Ak_cuda = compute_Ak_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute A(k) using CPU
    std::complex<double> Ak_cpu = affine_dof->compute_A(geom, k, dofs);
    
    // Compute analytical ground truth (for unit cube at origin)
    // For a unit cube centered at origin: A(k) = i*k * F(k) where F(k) is the form factor
    double kx = k.x(), ky = k.y(), kz = k.z();
    double kmag = k.norm();
    if (kmag < 1e-10) continue;
    
    // Form factor: F(k) = sinc(kx/2) * sinc(ky/2) * sinc(kz/2)
    auto sinc = [](double x) {
      if (std::abs(x) < 1e-4) return 1.0 - x*x/6.0;
      return std::sin(x) / x;
    };
    double F = sinc(0.5*kx) * sinc(0.5*ky) * sinc(0.5*kz);
    
    // A(k) = i*k * F(k) = i * (k·khat) * F(k) where khat = k/|k|
    // Actually, A_parallel(k) = (k·A(k))/|k|, and for a cube, A(k) = i*k*F(k)
    // So A_parallel(k) = i*|k|*F(k)
    std::complex<double> Ak_analytical = std::complex<double>(0.0, 1.0) * kmag * F;
    
    // Compare CUDA vs CPU
    std::complex<double> diff_cpu = Ak_cuda - Ak_cpu;
    double error_cpu = std::abs(diff_cpu) / std::max(std::abs(Ak_cuda), std::abs(Ak_cpu));
    if (error_cpu > max_error_cpu) max_error_cpu = error_cpu;
    
    // Compare CUDA vs Analytical
    std::complex<double> diff_analytical = Ak_cuda - Ak_analytical;
    double error_analytical = std::abs(diff_analytical) / std::max(std::abs(Ak_cuda), std::abs(Ak_analytical));
    if (error_analytical > max_error_analytical) max_error_analytical = error_analytical;
    
    if ((error_cpu > 0.01 || error_analytical > 0.1) && num_warnings < 5) {
      std::cout << "  k = (" << kx << ", " << ky << ", " << kz << "), |k| = " << kmag << ":" << std::endl;
      std::cout << "    CUDA:       " << Ak_cuda << std::endl;
      std::cout << "    CPU:        " << Ak_cpu << std::endl;
      std::cout << "    Analytical: " << Ak_analytical << std::endl;
      std::cout << "    Error (CUDA vs CPU): " << error_cpu << std::endl;
      std::cout << "    Error (CUDA vs Analytical): " << error_analytical << std::endl;
      num_warnings++;
    }
    
    num_tested++;
  }
  
  std::cout << "  Tested " << num_tested << " k-vectors" << std::endl;
  std::cout << "  Max error (CUDA vs CPU): " << max_error_cpu << std::endl;
  std::cout << "  Max error (CUDA vs Analytical): " << max_error_analytical << std::endl;
  
  bool passed = (max_error_cpu < 0.05) && (max_error_analytical < 0.2);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 2: Test ∂A(k)/∂θ computation
// ============================================================================

bool test_phase2_Ak_gradient_computation() {
  std::cout << "\n=== Phase 2 Test: ∂A(k)/∂θ Computation ===" << std::endl;
  
  // Create unit cube mesh
  Eigen::MatrixXd V;
  Eigen::MatrixXi F;
  create_unit_cube_mesh(V, F);
  auto geom = make_triangle_mesh(V, F);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test different DoF configurations
  std::vector<Eigen::VectorXd> test_dofs = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.1, 0.2, 0.3, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1)).finished(),
  };
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.5, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
  };
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& dofs : test_dofs) {
    for (const auto& k : test_k_vectors) {
      // Compute gradient using CUDA
      Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
      
      // Compute gradient using CPU
      Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
      
      // Compare
      for (int i = 0; i < grad_cuda.size(); ++i) {
        std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(grad_cuda(i));
        double abs_cpu = std::abs(grad_cpu(i));
        double max_abs = std::max(abs_cuda, abs_cpu);
        
        // Use absolute error if either value is very small, or if relative error would be misleading
        bool use_absolute = (max_abs < 1e-6);
        double error;
        if (use_absolute) {
          // For near-zero values, use absolute error normalized by 1e-5 threshold
          // This allows errors up to 1e-5 to pass (normalized error = 1.0)
          error = abs_error / 1e-5;
        } else {
          // For non-zero values, use relative error
          error = abs_error / max_abs;
        }
        
        if (error > max_error) max_error = error;
        
        // Only warn for errors that would cause test failure (error > 1.0)
        if (error > 1.0 && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for DoF " << i << std::endl;
          std::cout << "    k = (" << k.x() << ", " << k.y() << ", " << k.z() << ")" << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << std::endl;
          std::cout << "    CPU:  " << grad_cpu(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << " (normalized: " << error << ", threshold: 1e-5)" << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  
  // For near-zero values (|value| < 1e-6), we use normalized absolute error (error / 1e-5)
  //   This allows absolute errors up to 1e-5 to pass
  // For non-zero values, we use relative error
  //   This allows relative errors up to 50% to pass
  // Overall threshold: allow up to 1.0 (either 1e-5 absolute error or 100% relative error)
  bool passed = max_error < 1.0;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 2 Advanced: Test ∂A(k)/∂θ computation over entire KGrid
// ============================================================================

bool test_phase2_Ak_gradient_computation_advanced(const std::string& leb_file) {
  std::cout << "\n=== Phase 2 Advanced Test: ∂A(k)/∂θ Computation (Full KGrid) ===" << std::endl;
  
  // Create unit cube mesh
  Eigen::MatrixXd V;
  Eigen::MatrixXi F;
  create_unit_cube_mesh(V, F);
  auto geom = make_triangle_mesh(V, F);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test DoF configuration (identity transformation)
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load small Lebedev grid and build KGrid
  // Try to use lebedev_005.txt if available, otherwise use the provided file
  std::string small_leb_file = leb_file;
  size_t last_slash = leb_file.find_last_of("/\\");
  if (last_slash != std::string::npos) {
    std::string dir = leb_file.substr(0, last_slash + 1);
    small_leb_file = dir + "lebedev_005.txt";
  } else {
    // Try to use default path structure
#ifdef POINTINT_SOURCE_DIR
    std::string source_dir = POINTINT_SOURCE_DIR;
    // Convert backslashes to forward slashes
    for (size_t i = 0; i < source_dir.length(); ++i) {
      if (source_dir[i] == '\\') source_dir[i] = '/';
    }
    small_leb_file = source_dir + "/data/lebedev/lebedev_005.txt";
#else
    small_leb_file = "lebedev_005.txt";
#endif
  }
  
  LebedevGrid L;
  try {
    L = load_lebedev_txt(small_leb_file);
    std::cout << "  Using Lebedev file: " << small_leb_file << std::endl;
  } catch (...) {
    // If lebedev_005.txt not found, try to use the provided file
    std::cout << "  Note: Could not load lebedev_005.txt, using provided file instead" << std::endl;
    L = load_lebedev_txt(leb_file);
  }
  
  int nRad = 4;
  KGrid KG = build_kgrid(L.dirs, L.weights, nRad);
  int Q = KG.dirs.size();
  
  std::cout << "  Using KGrid with " << Q << " k-nodes (Lebedev: " << L.dirs.size() 
            << " directions, Radial: " << nRad << " points)" << std::endl;
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  int num_failed = 0;
  
  // Test over all k-vectors in the KGrid
  for (int q = 0; q < Q; ++q) {
    // Construct k-vector from KGrid
    Eigen::Vector3d k(
      KG.dirs[q][0] * KG.kmag[q],
      KG.dirs[q][1] * KG.kmag[q],
      KG.dirs[q][2] * KG.kmag[q]
    );
    
    // Compute gradient using CUDA
    Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute gradient using CPU
    Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
    
    // Compare each DoF component
    for (int i = 0; i < grad_cuda.size(); ++i) {
      std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
      double abs_error = std::abs(diff);
      double abs_cuda = std::abs(grad_cuda(i));
      double abs_cpu = std::abs(grad_cpu(i));
      double max_abs = std::max(abs_cuda, abs_cpu);
      double min_abs = std::min(abs_cuda, abs_cpu);
      
      // Use absolute error if both values are very small, or if one is near zero
      // This handles cases where one value is essentially zero and the other is small
      bool use_absolute = (max_abs < 1e-4) || (min_abs < 1e-10 && max_abs < 1e-4);
      double error;
      if (use_absolute) {
        // For near-zero values, use absolute error normalized by 1e-4 threshold
        // This is more lenient than 1e-5 to account for numerical precision differences
        error = abs_error / 1e-4;
      } else {
        // For non-zero values, use relative error
        error = abs_error / max_abs;
      }
      
      if (error > max_error) max_error = error;
      
      // Track failures (error > 2.0 for absolute, > 0.1 for relative)
      // More lenient thresholds for this comprehensive test
      double failure_threshold = use_absolute ? 2.0 : 0.1;
      if (error > failure_threshold) {
        num_failed++;
        // Only print warnings for first few failures to avoid spam
        if (num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for k-node " << q << ", DoF " << i << std::endl;
          std::cout << "    k = (" << k.x() << ", " << k.y() << ", " << k.z() << "), |k| = " << k.norm() << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << std::endl;
          std::cout << "    CPU:  " << grad_cpu(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << " (normalized: " << error << ", threshold: 1e-4)" << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
      }
      
      num_tested++;
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components over " << Q << " k-nodes" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  std::cout << "  Failed components: " << num_failed << " / " << num_tested 
            << " (" << (100.0 * num_failed / num_tested) << "%)" << std::endl;
  
  // Pass if failure rate is low (< 5%)
  // For this comprehensive test, we're more lenient since we're testing many edge cases
  // The max error threshold is handled per-component above
  bool passed = (num_failed < 0.05 * num_tested);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 3: Test intersection volume gradient (full pipeline)
// ============================================================================
bool test_intersection_volume_gradient_affine(const std::string& leb_file) {
  std::cout << "\n=== Test 1: Intersection Volume Gradient (AffineDoF, Triangle Meshes) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += translation;
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  std::vector<Eigen::VectorXd> test_dofs1 = {
    // Identity: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    // Small translation: [0.1, 0.0, 0.0, 1, 0, 0, 0, 1, 0, 0, 0, 1]
    (Eigen::VectorXd(12) << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    // Rotation around z-axis: [0, 0, 0, cos(0.1), -sin(0.1), 0, sin(0.1), cos(0.1), 0, 0, 0, 1]
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1), 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  std::vector<Eigen::VectorXd> test_dofs2 = {
    // Identity
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    // Small translation
    (Eigen::VectorXd(12) << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 1);
  
  double max_error_geom1 = 0.0;
  double max_error_geom2 = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& dofs1 : test_dofs1) {
    for (const auto& dofs2 : test_dofs2) {
      // Compute gradient using CUDA
      auto result = compute_intersection_volume_gradient_cuda(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 256, false
      );
      
      // Compute gradient using finite differencing
      Eigen::VectorXd grad_fd1 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1, 1e-2
      );
      
      Eigen::VectorXd grad_fd2 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 2, 1e-2
      );
      
      // Compare gradients for geometry 1
      for (int i = 0; i < result.grad_geom1.size(); ++i) {
        double diff = result.grad_geom1(i) - grad_fd1(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(result.grad_geom1(i));
        double abs_fd = std::abs(grad_fd1(i));
        
        // Use absolute error if both are near zero, otherwise use relative error
        bool use_absolute = (abs_cuda < 1e-3 && abs_fd < 1e-3);
        double error = use_absolute ? abs_error : (abs_error / std::max(abs_cuda, abs_fd));
        
        if (error > max_error_geom1) {
          max_error_geom1 = error;
        }
        
        double tolerance = use_absolute ? 1e-3 : 0.1;  // 10% relative or 1e-3 absolute
        if (error > tolerance && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for geom1 DoF " << i << std::endl;
          std::cout << "    CUDA:     " << result.grad_geom1(i) << std::endl;
          std::cout << "    Finite:   " << grad_fd1(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
      
      // Compare gradients for geometry 2
      for (int i = 0; i < result.grad_geom2.size(); ++i) {
        double diff = result.grad_geom2(i) - grad_fd2(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(result.grad_geom2(i));
        double abs_fd = std::abs(grad_fd2(i));
        
        // Use absolute error if both are near zero, otherwise use relative error
        bool use_absolute = (abs_cuda < 1e-3 && abs_fd < 1e-3);
        double error = use_absolute ? abs_error : (abs_error / std::max(abs_cuda, abs_fd));
        
        if (error > max_error_geom2) {
          max_error_geom2 = error;
        }
        
        double tolerance = use_absolute ? 1e-3 : 0.1;  // 10% relative or 1e-3 absolute
        if (error > tolerance && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for geom2 DoF " << i << std::endl;
          std::cout << "    CUDA:     " << result.grad_geom2(i) << std::endl;
          std::cout << "    Finite:   " << grad_fd2(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max error (geom1): " << max_error_geom1 << std::endl;
  std::cout << "  Max error (geom2): " << max_error_geom2 << std::endl;
  
  // Pass if max error is reasonable (10% relative or 1e-3 absolute)
  bool passed = (max_error_geom1 < 0.2) && (max_error_geom2 < 0.2);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 3.1: Intersection Volume Gradient Consistency Check
bool test_intersection_volume_gradient_consistency(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.1: Intersection Volume Gradient Consistency ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Base DoFs (identity)
  Eigen::VectorXd dofs1_base(12);
  dofs1_base << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  Eigen::VectorXd dofs2_base(12);
  dofs2_base << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 52);
  
  // Compute base volume
  Geometry geom1_base = affine_dof1->apply(geom1, dofs1_base);
  Geometry geom2_base = affine_dof2->apply(geom2, dofs2_base);
  double vol_base = compute_intersection_volume_cuda(geom1_base, geom2_base, KG, 256, true);
  
  // Compute gradient
  auto result = compute_intersection_volume_gradient_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1_base, dofs2_base, KG, 256, true
  );
  
  // Perturb DoFs and check volume change
  double eps = 1e-5;
  double max_relative_error = 0.0;
  int num_tested = 0;
  
  // Test geometry 1 gradients
  for (int i = 0; i < result.grad_geom1.size(); ++i) {
    Eigen::VectorXd dofs1_pert = dofs1_base;
    dofs1_pert(i) += eps;
    
    double vol_pert = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1_pert, dofs2_base, KG, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    double vol_change = vol_pert - vol_base;
    double predicted_change = result.grad_geom1(i) * eps;
    
    double error = std::abs(vol_change - predicted_change);
    double rel_error = (std::abs(predicted_change) > 1e-10) ? (error / std::abs(predicted_change)) : error;
    
    if (rel_error > max_relative_error) {
      max_relative_error = rel_error;
    }
    
    num_tested++;
  }
  
  // Test geometry 2 gradients
  for (int i = 0; i < result.grad_geom2.size(); ++i) {
    Eigen::VectorXd dofs2_pert = dofs2_base;
    dofs2_pert(i) += eps;
    
    double vol_pert = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1_base, dofs2_pert, KG, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    double vol_change = vol_pert - vol_base;
    double predicted_change = result.grad_geom2(i) * eps;
    
    double error = std::abs(vol_change - predicted_change);
    double rel_error = (std::abs(predicted_change) > 1e-10) ? (error / std::abs(predicted_change)) : error;
    
    if (rel_error > max_relative_error) {
      max_relative_error = rel_error;
    }
    
    num_tested++;
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max relative error: " << max_relative_error << std::endl;
  
  // Pass if error is reasonable (20% tolerance for consistency check)
  bool passed = max_relative_error < 0.2;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 3.2: Volume Consistency (Triangles)
bool test_volume_consistency_triangles(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.2: Volume Consistency (Triangles) ===" << std::endl;
  
  // Create unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  V2.col(0).array() += 0.3;  // Translate in x-direction
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF with identity transformations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid and build k-grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  int radial_points = 52;
  KGrid KG = build_kgrid(L.dirs, L.weights, radial_points);
  
  // Compute volume using gradient routine
  auto result = compute_intersection_volume_gradient_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 256, true
  );
  double volume_from_gradient = result.volume;
  
  // Compute volume using standard routine (unified interface)
  double volume_from_standard = compute_intersection_volume_cuda(
    geom1_transformed, geom2_transformed, KG, 256, true
  );
  
  // Compare
  double error = std::abs(volume_from_gradient - volume_from_standard);
  double rel_error = (std::abs(volume_from_standard) > 1e-10) 
    ? (error / std::abs(volume_from_standard)) 
    : error;
  
  std::cout << "  Volume from gradient routine: " << std::scientific << std::setprecision(10) 
            << volume_from_gradient << std::endl;
  std::cout << "  Volume from standard routine: " << volume_from_standard << std::endl;
  std::cout << "  Absolute error: " << error << std::endl;
  std::cout << "  Relative error: " << std::fixed << std::setprecision(6) 
            << rel_error * 100.0 << "%" << std::endl;
  
  // Pass if relative error is small (< 1%)
  bool passed = rel_error < 0.01;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 3.3: Comprehensive Gradient Test (CPU vs GPU vs FD)
bool test_triangle_gradient_comprehensive(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.3: Triangle Gradient Comprehensive Test (CPU vs GPU vs FD) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += translation;
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  std::vector<Eigen::VectorXd> test_dofs1 = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1), 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  std::vector<Eigen::VectorXd> test_dofs2 = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 52);
  
  // Track errors for all comparisons
  double max_error_cpu_gpu_geom1 = 0.0;
  double max_error_cpu_gpu_geom2 = 0.0;
  double max_error_cpu_fd_geom1 = 0.0;
  double max_error_cpu_fd_geom2 = 0.0;
  double max_error_gpu_fd_geom1 = 0.0;
  double max_error_gpu_fd_geom2 = 0.0;
  
  int num_tested = 0;
  int num_warnings = 0;
  
  // Timing
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  
  for (const auto& dofs1 : test_dofs1) {
    for (const auto& dofs2 : test_dofs2) {
      // Compute gradient using CPU
      auto result_cpu = compute_intersection_volume_cpu(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
        static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), false
      );
      
      // Compute gradient using GPU
      auto result_gpu = compute_intersection_volume_cuda(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
        static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), 256, false
      );
      
      // Compute gradient using finite differencing (uses GPU for volume computation)
      Eigen::VectorXd grad_fd1 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1, 1e-4
      );
      Eigen::VectorXd grad_fd2 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 2, 1e-4
      );
      
      // Compare all pairs
      for (int i = 0; i < result_cpu.grad_geom1.size(); ++i) {
        // CPU vs GPU
        {
          double diff = result_cpu.grad_geom1(i) - result_gpu.grad_geom1(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom1(i));
          double abs_gpu = std::abs(result_gpu.grad_geom1(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_gpu < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_gpu));
          if (error > max_error_cpu_gpu_geom1) max_error_cpu_gpu_geom1 = error;
          
          double tolerance = use_absolute ? 1e-3 : 0.1;
          if (error > tolerance && num_warnings < 5) {
            std::cout << "  Warning: CPU vs GPU mismatch for geom1 DoF " << i << std::endl;
            std::cout << "    CPU: " << result_cpu.grad_geom1(i) << ", GPU: " << result_gpu.grad_geom1(i) << std::endl;
            num_warnings++;
          }
        }
        
        // CPU vs FD
        {
          double diff = result_cpu.grad_geom1(i) - grad_fd1(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom1(i));
          double abs_fd = std::abs(grad_fd1(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_fd));
          if (error > max_error_cpu_fd_geom1) max_error_cpu_fd_geom1 = error;
          
          double tolerance = use_absolute ? 1e-3 : 0.1;
          if (error > tolerance && num_warnings < 5) {
            std::cout << "  Warning: CPU vs FD mismatch for geom1 DoF " << i << std::endl;
            std::cout << "    CPU: " << result_cpu.grad_geom1(i) << ", FD: " << grad_fd1(i) << std::endl;
            num_warnings++;
          }
        }
        
        // GPU vs FD
        {
          double diff = result_gpu.grad_geom1(i) - grad_fd1(i);
          double abs_error = std::abs(diff);
          double abs_gpu = std::abs(result_gpu.grad_geom1(i));
          double abs_fd = std::abs(grad_fd1(i));
          bool use_absolute = (abs_gpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_gpu, abs_fd));
          if (error > max_error_gpu_fd_geom1) max_error_gpu_fd_geom1 = error;
          
          double tolerance = use_absolute ? 1e-3 : 0.1;
          if (error > tolerance && num_warnings < 5) {
            std::cout << "  Warning: GPU vs FD mismatch for geom1 DoF " << i << std::endl;
            std::cout << "    GPU: " << result_gpu.grad_geom1(i) << ", FD: " << grad_fd1(i) << std::endl;
            num_warnings++;
          }
        }
        
        num_tested++;
      }
      
      // Same for geometry 2
      for (int i = 0; i < result_cpu.grad_geom2.size(); ++i) {
        // CPU vs GPU
        {
          double diff = result_cpu.grad_geom2(i) - result_gpu.grad_geom2(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom2(i));
          double abs_gpu = std::abs(result_gpu.grad_geom2(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_gpu < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_gpu));
          if (error > max_error_cpu_gpu_geom2) max_error_cpu_gpu_geom2 = error;
        }
        
        // CPU vs FD
        {
          double diff = result_cpu.grad_geom2(i) - grad_fd2(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom2(i));
          double abs_fd = std::abs(grad_fd2(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_fd));
          if (error > max_error_cpu_fd_geom2) max_error_cpu_fd_geom2 = error;
        }
        
        // GPU vs FD
        {
          double diff = result_gpu.grad_geom2(i) - grad_fd2(i);
          double abs_error = std::abs(diff);
          double abs_gpu = std::abs(result_gpu.grad_geom2(i));
          double abs_fd = std::abs(grad_fd2(i));
          bool use_absolute = (abs_gpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_gpu, abs_fd));
          if (error > max_error_gpu_fd_geom2) max_error_gpu_fd_geom2 = error;
        }
        
        num_tested++;
      }
    }
  }
  
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(
    t_cpu_end - t_cpu_start).count() / 1000.0;
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(
    t_gpu_end - t_gpu_start).count() / 1000.0;
  
  // Print summary
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "\n  Max errors:" << std::endl;
  std::cout << "    CPU vs GPU (geom1): " << max_error_cpu_gpu_geom1 << std::endl;
  std::cout << "    CPU vs GPU (geom2): " << max_error_cpu_gpu_geom2 << std::endl;
  std::cout << "    CPU vs FD (geom1):  " << max_error_cpu_fd_geom1 << std::endl;
  std::cout << "    CPU vs FD (geom2):  " << max_error_cpu_fd_geom2 << std::endl;
  std::cout << "    GPU vs FD (geom1):  " << max_error_gpu_fd_geom1 << std::endl;
  std::cout << "    GPU vs FD (geom2):  " << max_error_gpu_fd_geom2 << std::endl;
  std::cout << "\n  Timing:" << std::endl;
  std::cout << "    CPU time: " << std::fixed << std::setprecision(3) << cpu_time << " ms" << std::endl;
  std::cout << "    GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "    Speedup: " << std::setprecision(2) << (cpu_time / gpu_time) << "x" << std::endl;
  
  bool passed = (max_error_cpu_gpu_geom1 < 0.2) && (max_error_cpu_gpu_geom2 < 0.2) &&
                (max_error_cpu_fd_geom1 < 0.2) && (max_error_cpu_fd_geom2 < 0.2) &&
                (max_error_gpu_fd_geom1 < 0.2) && (max_error_gpu_fd_geom2 < 0.2);
  std::cout << "\n  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Disk/Point Cloud Tests
// ============================================================================

// ============================================================================
// Phase 1: Test A(k) computation for disks
// ============================================================================
bool test_phase1_Ak_computation_disk() {
  std::cout << "\n=== Phase 1 Test (Disks): A(k) Computation ===" << std::endl;
  
  // Create unit sphere point cloud
  Eigen::MatrixXd P, N;
  Eigen::VectorXd radii;
  create_sphere_pointcloud(P, N, radii, 1000);
  auto geom = make_point_cloud(P, N, radii, true);
  
  // Create AffineDoF with identity transformation
  auto affine_dof = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.1, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(0.0, 0.0, 2.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 1.0),
  };
  
  double max_error_cpu = 0.0;
  double max_error_analytical = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& k : test_k_vectors) {
    // Compute A(k) using CUDA
    std::complex<double> Ak_cuda = compute_Ak_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute A(k) using CPU
    std::complex<double> Ak_cpu = affine_dof->compute_A(geom, k, dofs);
    
    // Compute analytical ground truth (for unit sphere at origin)
    // For a unit sphere: A(k) = i*k * F(k) where F(k) is the form factor
    double kmag = k.norm();
    if (kmag < 1e-10) continue;
    
    // Use exact form factor from form_factor_helpers for unit sphere (R=1.0)
    double F = exact_sphere_form_factor(kmag, 1.0);
    
    // A(k) = i*k*F(k) for sphere
    // Note: The point cloud representation may not exactly match the analytical sphere
    // due to discretization, so we're more lenient with the analytical comparison
    std::complex<double> Ak_analytical = std::complex<double>(0.0, 1.0) * kmag * F;
    
    // Compare CUDA vs CPU (should match exactly)
    std::complex<double> diff_cpu = Ak_cuda - Ak_cpu;
    double error_cpu = std::abs(diff_cpu) / std::max(std::abs(Ak_cuda), std::abs(Ak_cpu));
    if (error_cpu > max_error_cpu) max_error_cpu = error_cpu;
    
    // Compare CUDA vs Analytical (more lenient due to discretization)
    std::complex<double> diff_analytical = Ak_cuda - Ak_analytical;
    double error_analytical = std::abs(diff_analytical) / std::max(std::abs(Ak_cuda), std::abs(Ak_analytical));
    if (error_analytical > max_error_analytical) max_error_analytical = error_analytical;
    
    // Only warn if CUDA vs CPU error is significant (analytical comparison is less strict)
    if ((error_cpu > 0.01 || error_analytical > 0.8) && num_warnings < 5) {
      std::cout << "  k = (" << k.x() << ", " << k.y() << ", " << k.z() << "), |k| = " << kmag << ":" << std::endl;
      std::cout << "    CUDA:       " << Ak_cuda << std::endl;
      std::cout << "    CPU:        " << Ak_cpu << std::endl;
      std::cout << "    Analytical: " << Ak_analytical << std::endl;
      std::cout << "    Error (CUDA vs CPU): " << error_cpu << std::endl;
      std::cout << "    Error (CUDA vs Analytical): " << error_analytical << std::endl;
      num_warnings++;
    }
    
    num_tested++;
  }
  
  std::cout << "  Tested " << num_tested << " k-vectors" << std::endl;
  std::cout << "  Max error (CUDA vs CPU): " << max_error_cpu << std::endl;
  std::cout << "  Max error (CUDA vs Analytical): " << max_error_analytical << std::endl;
  std::cout << "  Note: Analytical comparison is lenient due to point cloud discretization" << std::endl;
  
  // CUDA vs CPU should match exactly; analytical comparison is more lenient
  bool passed = (max_error_cpu < 0.05) && (max_error_analytical < 0.9);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 2: Test ∂A(k)/∂θ computation for disks
bool test_phase2_Ak_gradient_computation_disk() {
  std::cout << "\n=== Phase 2 Test (Disks): ∂A(k)/∂θ Computation ===" << std::endl;
  
  // Create unit sphere point cloud
  Eigen::MatrixXd P, N;
  Eigen::VectorXd radii;
  create_sphere_pointcloud(P, N, radii, 1000);
  auto geom = make_point_cloud(P, N, radii, true);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test different DoF configurations
  std::vector<Eigen::VectorXd> test_dofs = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.1, 0.2, 0.3, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1)).finished(),
  };
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.5, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
  };
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& dofs : test_dofs) {
    for (const auto& k : test_k_vectors) {
      // Compute gradient using CUDA
      Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
      
      // Compute gradient using CPU
      Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
      
      // Compare
      for (int i = 0; i < grad_cuda.size(); ++i) {
        std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(grad_cuda(i));
        double abs_cpu = std::abs(grad_cpu(i));
        double max_abs = std::max(abs_cuda, abs_cpu);
        
        // Use absolute error if either value is very small
        bool use_absolute = (max_abs < 1e-6);
        double error;
        if (use_absolute) {
          error = abs_error / 1e-5;
        } else {
          error = abs_error / max_abs;
        }
        
        if (error > max_error) max_error = error;
        
        if (error > 1.0 && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for DoF " << i << std::endl;
          std::cout << "    k = (" << k.x() << ", " << k.y() << ", " << k.z() << ")" << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << std::endl;
          std::cout << "    CPU:  " << grad_cpu(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << " (normalized: " << error << ", threshold: 1e-5)" << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  
  bool passed = max_error < 1.0;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 2 Advanced: Test ∂A(k)/∂θ computation over entire KGrid for disks
bool test_phase2_Ak_gradient_computation_advanced_disk(const std::string& leb_file) {
  std::cout << "\n=== Phase 2 Advanced Test (Disks): ∂A(k)/∂θ Computation (Full KGrid) ===" << std::endl;
  
  // Create unit sphere point cloud
  Eigen::MatrixXd P, N;
  Eigen::VectorXd radii;
  create_sphere_pointcloud(P, N, radii, 1000);
  auto geom = make_point_cloud(P, N, radii, true);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test DoF configuration (identity transformation)
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load small Lebedev grid and build KGrid
  // Try to use lebedev_005.txt if available, otherwise use the provided file
  std::string small_leb_file = leb_file;
  size_t last_slash = leb_file.find_last_of("/\\");
  if (last_slash != std::string::npos) {
    std::string dir = leb_file.substr(0, last_slash + 1);
    small_leb_file = dir + "lebedev_005.txt";
  } else {
    // Try to use default path structure
#ifdef POINTINT_SOURCE_DIR
    std::string source_dir = POINTINT_SOURCE_DIR;
    // Convert backslashes to forward slashes
    for (size_t i = 0; i < source_dir.length(); ++i) {
      if (source_dir[i] == '\\') source_dir[i] = '/';
    }
    small_leb_file = source_dir + "/data/lebedev/lebedev_005.txt";
#else
    small_leb_file = "lebedev_005.txt";
#endif
  }
  
  LebedevGrid L;
  try {
    L = load_lebedev_txt(small_leb_file);
    std::cout << "  Using Lebedev file: " << small_leb_file << std::endl;
  } catch (...) {
    // If lebedev_005.txt not found, try to use the provided file
    std::cout << "  Note: Could not load lebedev_005.txt, using provided file instead" << std::endl;
    L = load_lebedev_txt(leb_file);
  }
  
  int nRad = 8;
  KGrid KG = build_kgrid(L.dirs, L.weights, nRad);
  int Q = KG.dirs.size();
  
  std::cout << "  Using KGrid with " << Q << " k-nodes (Lebedev: " << L.dirs.size() 
            << " directions, Radial: " << nRad << " points)" << std::endl;
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  int num_failed = 0;
  
  // Test over all k-vectors in the KGrid
  for (int q = 0; q < Q; ++q) {
    // Construct k-vector from KGrid
    Eigen::Vector3d k(
      KG.dirs[q][0] * KG.kmag[q],
      KG.dirs[q][1] * KG.kmag[q],
      KG.dirs[q][2] * KG.kmag[q]
    );
    
    // Compute gradient using CUDA
    Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute gradient using CPU
    Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
    
    // Compare each DoF component
    for (int i = 0; i < grad_cuda.size(); ++i) {
      std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
      double abs_error = std::abs(diff);
      double abs_cuda = std::abs(grad_cuda(i));
      double abs_cpu = std::abs(grad_cpu(i));
      double max_abs = std::max(abs_cuda, abs_cpu);
      double min_abs = std::min(abs_cuda, abs_cpu);
      
      // Use absolute error if both values are very small, or if one is near zero
      // This handles cases where one value is essentially zero and the other is small
      bool use_absolute = (max_abs < 1e-4) || (min_abs < 1e-10 && max_abs < 1e-4);
      double error;
      if (use_absolute) {
        // For near-zero values, use absolute error normalized by 1e-4 threshold
        // This is more lenient than 1e-5 to account for numerical precision differences
        error = abs_error / 1e-4;
      } else {
        // For non-zero values, use relative error
        error = abs_error / max_abs;
      }
      
      if (error > max_error) max_error = error;
      
      // Track failures (error > 2.0 for absolute, > 0.1 for relative)
      // More lenient thresholds for this comprehensive test
      double failure_threshold = use_absolute ? 2.0 : 0.1;
      if (error > failure_threshold) {
        num_failed++;
        // Only print warnings for first few failures to avoid spam
        if (num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for k-node " << q << ", DoF " << i << std::endl;
          std::cout << "    k = (" << k.x() << ", " << k.y() << ", " << k.z() << "), |k| = " << k.norm() << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << std::endl;
          std::cout << "    CPU:  " << grad_cpu(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << " (normalized: " << error << ", threshold: 1e-4)" << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
      }
      
      num_tested++;
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components over " << Q << " k-nodes" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  std::cout << "  Failed components: " << num_failed << " / " << num_tested 
            << " (" << (100.0 * num_failed / num_tested) << "%)" << std::endl;
  
  // Pass if failure rate is low (< 5%)
  // For this comprehensive test, we're more lenient since we're testing many edge cases
  // The max error threshold is handled per-component above
  bool passed = (num_failed < 0.05 * num_tested);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 3: Test intersection volume gradient (full pipeline)
// ============================================================================

// Phase 3.1: Comprehensive Gradient Test (CPU vs GPU vs FD)
bool test_disk_gradient_comprehensive(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.1: Disk Gradient Comprehensive Test (CPU vs GPU vs FD) ===" << std::endl;
  
  // Create two unit sphere point clouds
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd radii1, radii2;
  create_sphere_pointcloud(P1, N1, radii1, 1000);
  create_sphere_pointcloud(P2, N2, radii2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation;
  }
  
  auto geom1 = make_point_cloud(P1, N1, radii1, true);
  auto geom2 = make_point_cloud(P2, N2, radii2, true);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  std::vector<Eigen::VectorXd> test_dofs1 = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  std::vector<Eigen::VectorXd> test_dofs2 = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 52);
  
  // Track errors for all comparisons
  double max_error_cpu_gpu_geom1 = 0.0;
  double max_error_cpu_gpu_geom2 = 0.0;
  double max_error_cpu_fd_geom1 = 0.0;
  double max_error_cpu_fd_geom2 = 0.0;
  double max_error_gpu_fd_geom1 = 0.0;
  double max_error_gpu_fd_geom2 = 0.0;
  
  int num_tested = 0;
  int num_warnings = 0;
  
  // Timing
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  
  for (const auto& dofs1 : test_dofs1) {
    for (const auto& dofs2 : test_dofs2) {
      // Compute gradient using CPU
      auto result_cpu = compute_intersection_volume_cpu(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
        static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), false
      );
      
      // Compute gradient using GPU
      auto result_gpu = compute_intersection_volume_cuda(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
        static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), 256, false
      );
      
      // Compute gradient using finite differencing (uses GPU for volume computation)
      // Use smaller epsilon for disks because apply() scales rho/area based on det_A,
      // which makes the function more sensitive to perturbations
      Eigen::VectorXd grad_fd1 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1, 1e-6
      );
      Eigen::VectorXd grad_fd2 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 2, 1e-6
      );
      
      // Compare all pairs
      for (int i = 0; i < result_cpu.grad_geom1.size(); ++i) {
        // CPU vs GPU
        {
          double diff = result_cpu.grad_geom1(i) - result_gpu.grad_geom1(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom1(i));
          double abs_gpu = std::abs(result_gpu.grad_geom1(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_gpu < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_gpu));
          if (error > max_error_cpu_gpu_geom1) max_error_cpu_gpu_geom1 = error;
          
          double tolerance = use_absolute ? 1e-3 : 0.1;
          if (error > tolerance && num_warnings < 5) {
            std::cout << "  Warning: CPU vs GPU mismatch for geom1 DoF " << i << std::endl;
            std::cout << "    CPU: " << result_cpu.grad_geom1(i) << ", GPU: " << result_gpu.grad_geom1(i) << std::endl;
            num_warnings++;
          }
        }
        
        // CPU vs FD
        {
          double diff = result_cpu.grad_geom1(i) - grad_fd1(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom1(i));
          double abs_fd = std::abs(grad_fd1(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_fd));
          if (error > max_error_cpu_fd_geom1) max_error_cpu_fd_geom1 = error;
          
          double tolerance = use_absolute ? 1e-3 : 0.1;
          if (error > tolerance && num_warnings < 5) {
            std::cout << "  Warning: CPU vs FD mismatch for geom1 DoF " << i << std::endl;
            std::cout << "    CPU: " << result_cpu.grad_geom1(i) << ", FD: " << grad_fd1(i) << std::endl;
            num_warnings++;
          }
        }
        
        // GPU vs FD
        {
          double diff = result_gpu.grad_geom1(i) - grad_fd1(i);
          double abs_error = std::abs(diff);
          double abs_gpu = std::abs(result_gpu.grad_geom1(i));
          double abs_fd = std::abs(grad_fd1(i));
          bool use_absolute = (abs_gpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_gpu, abs_fd));
          if (error > max_error_gpu_fd_geom1) max_error_gpu_fd_geom1 = error;
          
          double tolerance = use_absolute ? 1e-3 : 0.1;
          if (error > tolerance && num_warnings < 5) {
            std::cout << "  Warning: GPU vs FD mismatch for geom1 DoF " << i << std::endl;
            std::cout << "    GPU: " << result_gpu.grad_geom1(i) << ", FD: " << grad_fd1(i) << std::endl;
            num_warnings++;
          }
        }
        
        num_tested++;
      }
      
      // Same for geometry 2
      for (int i = 0; i < result_cpu.grad_geom2.size(); ++i) {
        // CPU vs GPU
        {
          double diff = result_cpu.grad_geom2(i) - result_gpu.grad_geom2(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom2(i));
          double abs_gpu = std::abs(result_gpu.grad_geom2(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_gpu < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_gpu));
          if (error > max_error_cpu_gpu_geom2) max_error_cpu_gpu_geom2 = error;
        }
        
        // CPU vs FD
        {
          double diff = result_cpu.grad_geom2(i) - grad_fd2(i);
          double abs_error = std::abs(diff);
          double abs_cpu = std::abs(result_cpu.grad_geom2(i));
          double abs_fd = std::abs(grad_fd2(i));
          bool use_absolute = (abs_cpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_fd));
          if (error > max_error_cpu_fd_geom2) max_error_cpu_fd_geom2 = error;
        }
        
        // GPU vs FD
        {
          double diff = result_gpu.grad_geom2(i) - grad_fd2(i);
          double abs_error = std::abs(diff);
          double abs_gpu = std::abs(result_gpu.grad_geom2(i));
          double abs_fd = std::abs(grad_fd2(i));
          bool use_absolute = (abs_gpu < 1e-6 && abs_fd < 1e-6);
          double error = use_absolute ? abs_error : (abs_error / std::max(abs_gpu, abs_fd));
          if (error > max_error_gpu_fd_geom2) max_error_gpu_fd_geom2 = error;
        }
        
        num_tested++;
      }
    }
  }
  
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(
    t_cpu_end - t_cpu_start).count() / 1000.0;
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(
    t_gpu_end - t_gpu_start).count() / 1000.0;
  
  // Print summary
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "\n  Max errors:" << std::endl;
  std::cout << "    CPU vs GPU (geom1): " << max_error_cpu_gpu_geom1 << std::endl;
  std::cout << "    CPU vs GPU (geom2): " << max_error_cpu_gpu_geom2 << std::endl;
  std::cout << "    CPU vs FD (geom1):  " << max_error_cpu_fd_geom1 << std::endl;
  std::cout << "    CPU vs FD (geom2):  " << max_error_cpu_fd_geom2 << std::endl;
  std::cout << "    GPU vs FD (geom1):  " << max_error_gpu_fd_geom1 << std::endl;
  std::cout << "    GPU vs FD (geom2):  " << max_error_gpu_fd_geom2 << std::endl;
  std::cout << "\n  Timing:" << std::endl;
  std::cout << "    CPU time: " << std::fixed << std::setprecision(3) << cpu_time << " ms" << std::endl;
  std::cout << "    GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "    Speedup: " << std::setprecision(2) << (cpu_time / gpu_time) << "x" << std::endl;
  
  bool passed = (max_error_cpu_gpu_geom1 < 0.2) && (max_error_cpu_gpu_geom2 < 0.2) &&
                (max_error_cpu_fd_geom1 < 0.2) && (max_error_cpu_fd_geom2 < 0.2) &&
                (max_error_gpu_fd_geom1 < 0.2) && (max_error_gpu_fd_geom2 < 0.2);
  std::cout << "\n  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 3.2: Volume Consistency (Disks)
bool test_volume_consistency_disks(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.2: Volume Consistency (Disks) ===" << std::endl;
  
  // Create two unit sphere point clouds
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd radii1, radii2;
  create_sphere_pointcloud(P1, N1, radii1, 1000);
  create_sphere_pointcloud(P2, N2, radii2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation;
  }
  
  auto geom1 = make_point_cloud(P1, N1, radii1, true);
  auto geom2 = make_point_cloud(P2, N2, radii2, true);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  Eigen::VectorXd dofs1 = (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished();
  Eigen::VectorXd dofs2 = (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished();
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 52);
  
  // Compute volumes using different methods (unified interface)
  double vol_cpu_non_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false).volume;
  double vol_gpu_non_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false).volume;
  
  auto result_cpu_grad = compute_intersection_volume_cpu(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), false
  );
  double vol_cpu_grad = result_cpu_grad.volume;
  
  auto result_gpu_grad = compute_intersection_volume_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), 256, false
  );
  double vol_gpu_grad = result_gpu_grad.volume;
  
  // Print results
  std::cout << "  CPU (non-gradient):  " << std::scientific << std::setprecision(10) << vol_cpu_non_grad << std::endl;
  std::cout << "  GPU (non-gradient):  " << std::scientific << std::setprecision(10) << vol_gpu_non_grad << std::endl;
  std::cout << "  CPU (gradient):      " << std::scientific << std::setprecision(10) << vol_cpu_grad << std::endl;
  std::cout << "  GPU (gradient):      " << std::scientific << std::setprecision(10) << vol_gpu_grad << std::endl;
  
  // Compare all volumes
  double max_vol = std::max({std::abs(vol_cpu_non_grad), std::abs(vol_gpu_non_grad), 
                             std::abs(vol_cpu_grad), std::abs(vol_gpu_grad)});
  
  double tol = 1e-6;
  bool all_match = true;
  
  // Compare CPU non-gradient vs GPU non-gradient
  double diff1 = std::abs(vol_cpu_non_grad - vol_gpu_non_grad);
  double rel_error1 = (max_vol > 1e-10) ? diff1 / max_vol : diff1;
  if (rel_error1 > tol) {
    std::cout << "  ERROR: CPU (non-gradient) vs GPU (non-gradient) mismatch: " 
              << std::scientific << rel_error1 << std::endl;
    all_match = false;
  }
  
  // Compare CPU non-gradient vs CPU gradient
  double diff2 = std::abs(vol_cpu_non_grad - vol_cpu_grad);
  double rel_error2 = (max_vol > 1e-10) ? diff2 / max_vol : diff2;
  if (rel_error2 > tol) {
    std::cout << "  ERROR: CPU (non-gradient) vs CPU (gradient) mismatch: " 
              << std::scientific << rel_error2 << std::endl;
    all_match = false;
  }
  
  // Compare CPU non-gradient vs GPU gradient
  double diff3 = std::abs(vol_cpu_non_grad - vol_gpu_grad);
  double rel_error3 = (max_vol > 1e-10) ? diff3 / max_vol : diff3;
  if (rel_error3 > tol) {
    std::cout << "  ERROR: CPU (non-gradient) vs GPU (gradient) mismatch: " 
              << std::scientific << rel_error3 << std::endl;
    all_match = false;
  }
  
  // Compare GPU non-gradient vs CPU gradient
  double diff4 = std::abs(vol_gpu_non_grad - vol_cpu_grad);
  double rel_error4 = (max_vol > 1e-10) ? diff4 / max_vol : diff4;
  if (rel_error4 > tol) {
    std::cout << "  ERROR: GPU (non-gradient) vs CPU (gradient) mismatch: " 
              << std::scientific << rel_error4 << std::endl;
    all_match = false;
  }
  
  // Compare GPU non-gradient vs GPU gradient
  double diff5 = std::abs(vol_gpu_non_grad - vol_gpu_grad);
  double rel_error5 = (max_vol > 1e-10) ? diff5 / max_vol : diff5;
  if (rel_error5 > tol) {
    std::cout << "  ERROR: GPU (non-gradient) vs GPU (gradient) mismatch: " 
              << std::scientific << rel_error5 << std::endl;
    all_match = false;
  }
  
  // Compare CPU gradient vs GPU gradient
  double diff6 = std::abs(vol_cpu_grad - vol_gpu_grad);
  double rel_error6 = (max_vol > 1e-10) ? diff6 / max_vol : diff6;
  if (rel_error6 > tol) {
    std::cout << "  ERROR: CPU (gradient) vs GPU (gradient) mismatch: " 
              << std::scientific << rel_error6 << std::endl;
    all_match = false;
  }
  
  if (all_match) {
    std::cout << "  All volume computations match!" << std::endl;
  }
  
  std::cout << "  Result: " << (all_match ? "PASS" : "FAIL") << std::endl;
  
  return all_match;
}

// ============================================================================
// Gaussian Splat Tests
// ============================================================================

// Phase 1: Test A(k) computation for Gaussian splats
bool test_phase1_Ak_computation_gaussian() {
  std::cout << "\n=== Phase 1 Test (Gaussian Splats): A(k) Computation ===" << std::endl;
  
  // Create unit sphere Gaussian splats
  Eigen::MatrixXd P, N;
  Eigen::VectorXd sigmas, weights;
  create_sphere_gaussians(P, N, sigmas, weights, 1000);
  auto geom = make_gaussian_splat(P, N, sigmas, weights);
  
  // Create AffineDoF with identity transformation
  auto affine_dof = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.1, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(0.0, 0.0, 2.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 1.0),
  };
  
  double max_error_cpu = 0.0;
  double max_error_analytical = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& k : test_k_vectors) {
    // Compute A(k) using CUDA
    std::complex<double> Ak_cuda = compute_Ak_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute A(k) using CPU
    std::complex<double> Ak_cpu = affine_dof->compute_A(geom, k, dofs);
    
    // Compute analytical ground truth (for unit sphere at origin)
    double kmag = k.norm();
    if (kmag < 1e-10) continue;
    
    // Use exact form factor from form_factor_helpers for unit sphere (R=1.0)
    double F = exact_sphere_form_factor(kmag, 1.0);
    
    // A(k) = i*k*F(k) for sphere
    // Note: The Gaussian splat representation may not exactly match the analytical sphere
    // due to discretization, so we're more lenient with the analytical comparison
    std::complex<double> Ak_analytical = std::complex<double>(0.0, 1.0) * kmag * F;
    
    // Compare CUDA vs CPU (should match exactly)
    std::complex<double> diff_cpu = Ak_cuda - Ak_cpu;
    double error_cpu = std::abs(diff_cpu) / std::max(std::abs(Ak_cuda), std::abs(Ak_cpu));
    if (error_cpu > max_error_cpu) max_error_cpu = error_cpu;
    
    // Compare CUDA vs Analytical (more lenient due to discretization)
    std::complex<double> diff_analytical = Ak_cuda - Ak_analytical;
    double error_analytical = std::abs(diff_analytical) / std::max(std::abs(Ak_cuda), std::abs(Ak_analytical));
    if (error_analytical > max_error_analytical) max_error_analytical = error_analytical;
    
    // Only warn if CUDA vs CPU error is significant (analytical comparison is less strict)
    if ((error_cpu > 0.01 || error_analytical > 0.8) && num_warnings < 5) {
      std::cout << "  k = (" << k.x() << ", " << k.y() << ", " << k.z() << "), |k| = " << kmag << ":" << std::endl;
      std::cout << "    CUDA:       " << Ak_cuda << std::endl;
      std::cout << "    CPU:        " << Ak_cpu << std::endl;
      std::cout << "    Analytical: " << Ak_analytical << std::endl;
      std::cout << "    Error (CUDA vs CPU): " << error_cpu << std::endl;
      std::cout << "    Error (CUDA vs Analytical): " << error_analytical << std::endl;
      num_warnings++;
    }
    
    num_tested++;
  }
  
  std::cout << "  Tested " << num_tested << " k-vectors" << std::endl;
  std::cout << "  Max error (CUDA vs CPU): " << max_error_cpu << std::endl;
  std::cout << "  Max error (CUDA vs Analytical): " << max_error_analytical << std::endl;
  std::cout << "  Note: Analytical comparison is lenient due to Gaussian splat discretization" << std::endl;
  
  // CUDA vs CPU should match exactly; analytical comparison is more lenient
  bool passed = (max_error_cpu < 0.05) && (max_error_analytical < 0.9);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 2: Test ∂A(k)/∂θ computation for Gaussian splats
bool test_phase2_Ak_gradient_computation_gaussian() {
  std::cout << "\n=== Phase 2 Test (Gaussian Splats): ∂A(k)/∂θ Computation ===" << std::endl;
  
  // Create unit sphere Gaussian splats
  Eigen::MatrixXd P, N;
  Eigen::VectorXd sigmas, weights;
  create_sphere_gaussians(P, N, sigmas, weights, 1000);
  auto geom = make_gaussian_splat(P, N, sigmas, weights);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test different DoF configurations
  std::vector<Eigen::VectorXd> test_dofs = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.1, 0.2, 0.3, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1)).finished(),
  };
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.5, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
  };
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& dofs : test_dofs) {
    for (const auto& k : test_k_vectors) {
      // Compute gradient using CUDA
      Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
      
      // Compute gradient using CPU
      Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
      
      // Compare
      for (int i = 0; i < grad_cuda.size(); ++i) {
        std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(grad_cuda(i));
        double abs_cpu = std::abs(grad_cpu(i));
        bool use_absolute = (abs_cuda < 1e-6 && abs_cpu < 1e-6);
        double error = use_absolute ? abs_error : (abs_error / std::max(abs_cuda, abs_cpu));
        if (error > max_error) max_error = error;
        
        if (error > 1.0 && num_warnings < 5) {
          std::cout << "  Warning: Large error for DoF " << i << " at k = (" 
                    << k.x() << ", " << k.y() << ", " << k.z() << ")" << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << ", CPU: " << grad_cpu(i) << std::endl;
          std::cout << "    Error: " << error << std::endl;
          num_warnings++;
        }
      }
      num_tested++;
    }
  }
  
  std::cout << "  Tested " << num_tested << " (DoF, k) pairs" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  
  bool passed = max_error < 1.0;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Comprehensive gradient test for Gaussian splats (CPU vs GPU vs FD)
bool test_gaussian_gradient_comprehensive(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.1: Gaussian Splat Gradient Comprehensive Test (CPU vs GPU vs FD) ===" << std::endl;
  
  // Create two unit sphere Gaussian splats
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd sigmas1, weights1, sigmas2, weights2;
  create_sphere_gaussians(P1, N1, sigmas1, weights1, 1000);
  create_sphere_gaussians(P2, N2, sigmas2, weights2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d t2(0.5, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += t2;
  }
  
  auto geom1 = make_gaussian_splat(P1, N1, sigmas1, weights1);
  auto geom2 = make_gaussian_splat(P2, N2, sigmas2, weights2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  Eigen::VectorXd dofs1 = (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished();
  Eigen::VectorXd dofs2 = (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished();
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 32);  // Smaller grid for speed
  
  // Compute gradients using CPU
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), false
  );
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  // Compute gradients using GPU
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), 256, false
  );
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  // Compute gradients using finite differencing (using GPU non-gradient routine)
  // Use smaller epsilon for Gaussians because apply() scales sigma/weight based on det_A,
  // which makes the function more sensitive to perturbations
  Eigen::VectorXd grad_fd1 = compute_intersection_volume_gradient_finite_diff(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1, 1e-6
  );
  Eigen::VectorXd grad_fd2 = compute_intersection_volume_gradient_finite_diff(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 2, 1e-6
  );
  
  // Compare all pairs
  double max_error_cpu_gpu_geom1 = 0.0, max_error_cpu_gpu_geom2 = 0.0;
  double max_error_cpu_fd_geom1 = 0.0, max_error_cpu_fd_geom2 = 0.0;
  double max_error_gpu_fd_geom1 = 0.0, max_error_gpu_fd_geom2 = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (int i = 0; i < result_cpu.grad_geom1.size(); ++i) {
    // CPU vs GPU
    {
      double diff = result_cpu.grad_geom1(i) - result_gpu.grad_geom1(i);
      double abs_error = std::abs(diff);
      double abs_cpu = std::abs(result_cpu.grad_geom1(i));
      double abs_gpu = std::abs(result_gpu.grad_geom1(i));
      bool use_absolute = (abs_cpu < 1e-6 && abs_gpu < 1e-6);
      double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_gpu));
      if (error > max_error_cpu_gpu_geom1) max_error_cpu_gpu_geom1 = error;
      
      double tolerance = use_absolute ? 1e-3 : 0.1;
      if (error > tolerance && num_warnings < 5) {
        std::cout << "  Warning: CPU vs GPU mismatch for geom1 DoF " << i << std::endl;
        std::cout << "    CPU: " << result_cpu.grad_geom1(i) << ", GPU: " << result_gpu.grad_geom1(i) << std::endl;
        num_warnings++;
      }
    }
    
    // CPU vs FD
    {
      double diff = result_cpu.grad_geom1(i) - grad_fd1(i);
      double abs_error = std::abs(diff);
      double abs_cpu = std::abs(result_cpu.grad_geom1(i));
      double abs_fd = std::abs(grad_fd1(i));
      bool use_absolute = (abs_cpu < 1e-6 && abs_fd < 1e-6);
      double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_fd));
      if (error > max_error_cpu_fd_geom1) max_error_cpu_fd_geom1 = error;
    }
    
    // GPU vs FD
    {
      double diff = result_gpu.grad_geom1(i) - grad_fd1(i);
      double abs_error = std::abs(diff);
      double abs_gpu = std::abs(result_gpu.grad_geom1(i));
      double abs_fd = std::abs(grad_fd1(i));
      bool use_absolute = (abs_gpu < 1e-6 && abs_fd < 1e-6);
      double error = use_absolute ? abs_error : (abs_error / std::max(abs_gpu, abs_fd));
      if (error > max_error_gpu_fd_geom1) max_error_gpu_fd_geom1 = error;
    }
    
    num_tested++;
  }
  
  // Same for geometry 2
  for (int i = 0; i < result_cpu.grad_geom2.size(); ++i) {
    // CPU vs GPU
    {
      double diff = result_cpu.grad_geom2(i) - result_gpu.grad_geom2(i);
      double abs_error = std::abs(diff);
      double abs_cpu = std::abs(result_cpu.grad_geom2(i));
      double abs_gpu = std::abs(result_gpu.grad_geom2(i));
      bool use_absolute = (abs_cpu < 1e-6 && abs_gpu < 1e-6);
      double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_gpu));
      if (error > max_error_cpu_gpu_geom2) max_error_cpu_gpu_geom2 = error;
    }
    
    // CPU vs FD
    {
      double diff = result_cpu.grad_geom2(i) - grad_fd2(i);
      double abs_error = std::abs(diff);
      double abs_cpu = std::abs(result_cpu.grad_geom2(i));
      double abs_fd = std::abs(grad_fd2(i));
      bool use_absolute = (abs_cpu < 1e-6 && abs_fd < 1e-6);
      double error = use_absolute ? abs_error : (abs_error / std::max(abs_cpu, abs_fd));
      if (error > max_error_cpu_fd_geom2) max_error_cpu_fd_geom2 = error;
    }
    
    // GPU vs FD
    {
      double diff = result_gpu.grad_geom2(i) - grad_fd2(i);
      double abs_error = std::abs(diff);
      double abs_gpu = std::abs(result_gpu.grad_geom2(i));
      double abs_fd = std::abs(grad_fd2(i));
      bool use_absolute = (abs_gpu < 1e-6 && abs_fd < 1e-6);
      double error = use_absolute ? abs_error : (abs_error / std::max(abs_gpu, abs_fd));
      if (error > max_error_gpu_fd_geom2) max_error_gpu_fd_geom2 = error;
    }
  }
  
  std::cout << "\n  Max Errors:" << std::endl;
  std::cout << "    CPU vs GPU (geom1):  " << max_error_cpu_gpu_geom1 << std::endl;
  std::cout << "    CPU vs GPU (geom2):  " << max_error_cpu_gpu_geom2 << std::endl;
  std::cout << "    CPU vs FD (geom1):   " << max_error_cpu_fd_geom1 << std::endl;
  std::cout << "    CPU vs FD (geom2):   " << max_error_cpu_fd_geom2 << std::endl;
  std::cout << "    GPU vs FD (geom1):   " << max_error_gpu_fd_geom1 << std::endl;
  std::cout << "    GPU vs FD (geom2):   " << max_error_gpu_fd_geom2 << std::endl;
  std::cout << "\n  Timing:" << std::endl;
  std::cout << "    CPU time: " << std::fixed << std::setprecision(3) << cpu_time << " ms" << std::endl;
  std::cout << "    GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "    Speedup: " << std::setprecision(2) << (cpu_time / gpu_time) << "x" << std::endl;
  
  bool passed = (max_error_cpu_gpu_geom1 < 0.2) && (max_error_cpu_gpu_geom2 < 0.2) &&
                (max_error_cpu_fd_geom1 < 0.2) && (max_error_cpu_fd_geom2 < 0.2) &&
                (max_error_gpu_fd_geom1 < 0.2) && (max_error_gpu_fd_geom2 < 0.2);
  std::cout << "\n  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// Phase 3.2: Volume Consistency (Gaussian Splats)
bool test_volume_consistency_gaussians(const std::string& leb_file) {
  std::cout << "\n=== Phase 3.2: Volume Consistency (Gaussian Splats) ===" << std::endl;
  
  // Create two unit sphere Gaussian splats
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd sigmas1, weights1, sigmas2, weights2;
  create_sphere_gaussians(P1, N1, sigmas1, weights1, 1000);
  create_sphere_gaussians(P2, N2, sigmas2, weights2, 1000);
  
  auto geom1 = make_gaussian_splat(P1, N1, sigmas1, weights1);
  auto geom2 = make_gaussian_splat(P2, N2, sigmas2, weights2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  Eigen::VectorXd dofs1 = (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished();
  Eigen::VectorXd dofs2 = (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished();
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 52);
  
  // Compute volumes using different methods (unified interface)
  double vol_cpu_non_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false).volume;
  double vol_gpu_non_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false).volume;
  
  auto result_cpu_grad = compute_intersection_volume_cpu(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), false
  );
  double vol_cpu_grad = result_cpu_grad.volume;
  
  auto result_gpu_grad = compute_intersection_volume_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(ComputationFlags::VOLUME_ONLY | ComputationFlags::GRADIENT), 256, false
  );
  double vol_gpu_grad = result_gpu_grad.volume;
  
  // Print results
  std::cout << "  CPU (non-gradient):  " << std::scientific << std::setprecision(10) << vol_cpu_non_grad << std::endl;
  std::cout << "  GPU (non-gradient):  " << std::scientific << std::setprecision(10) << vol_gpu_non_grad << std::endl;
  std::cout << "  CPU (gradient):      " << std::scientific << std::setprecision(10) << vol_cpu_grad << std::endl;
  std::cout << "  GPU (gradient):      " << std::scientific << std::setprecision(10) << vol_gpu_grad << std::endl;
  
  // Compare all volumes
  double max_vol = std::max({std::abs(vol_cpu_non_grad), std::abs(vol_gpu_non_grad), 
                             std::abs(vol_cpu_grad), std::abs(vol_gpu_grad)});
  
  double tol = 1e-6;
  bool all_match = true;
  
  // Compare CPU non-gradient vs GPU non-gradient
  double diff1 = std::abs(vol_cpu_non_grad - vol_gpu_non_grad);
  double rel_error1 = (max_vol > 1e-10) ? diff1 / max_vol : diff1;
  if (rel_error1 > tol) {
    std::cout << "  ERROR: CPU (non-gradient) vs GPU (non-gradient) mismatch: " 
              << std::scientific << rel_error1 << std::endl;
    all_match = false;
  }
  
  // Compare CPU non-gradient vs CPU gradient
  double diff2 = std::abs(vol_cpu_non_grad - vol_cpu_grad);
  double rel_error2 = (max_vol > 1e-10) ? diff2 / max_vol : diff2;
  if (rel_error2 > tol) {
    std::cout << "  ERROR: CPU (non-gradient) vs CPU (gradient) mismatch: " 
              << std::scientific << rel_error2 << std::endl;
    all_match = false;
  }
  
  // Compare CPU non-gradient vs GPU gradient
  double diff3 = std::abs(vol_cpu_non_grad - vol_gpu_grad);
  double rel_error3 = (max_vol > 1e-10) ? diff3 / max_vol : diff3;
  if (rel_error3 > tol) {
    std::cout << "  ERROR: CPU (non-gradient) vs GPU (gradient) mismatch: " 
              << std::scientific << rel_error3 << std::endl;
    all_match = false;
  }
  
  // Compare GPU non-gradient vs CPU gradient
  double diff4 = std::abs(vol_gpu_non_grad - vol_cpu_grad);
  double rel_error4 = (max_vol > 1e-10) ? diff4 / max_vol : diff4;
  if (rel_error4 > tol) {
    std::cout << "  ERROR: GPU (non-gradient) vs CPU (gradient) mismatch: " 
              << std::scientific << rel_error4 << std::endl;
    all_match = false;
  }
  
  // Compare GPU non-gradient vs GPU gradient
  double diff5 = std::abs(vol_gpu_non_grad - vol_gpu_grad);
  double rel_error5 = (max_vol > 1e-10) ? diff5 / max_vol : diff5;
  if (rel_error5 > tol) {
    std::cout << "  ERROR: GPU (non-gradient) vs GPU (gradient) mismatch: " 
              << std::scientific << rel_error5 << std::endl;
    all_match = false;
  }
  
  // Compare CPU gradient vs GPU gradient
  double diff6 = std::abs(vol_cpu_grad - vol_gpu_grad);
  double rel_error6 = (max_vol > 1e-10) ? diff6 / max_vol : diff6;
  if (rel_error6 > tol) {
    std::cout << "  ERROR: CPU (gradient) vs GPU (gradient) mismatch: " 
              << std::scientific << rel_error6 << std::endl;
    all_match = false;
  }
  
  if (all_match) {
    std::cout << "  All volume computations match!" << std::endl;
  }
  
  std::cout << "  Result: " << (all_match ? "PASS" : "FAIL") << std::endl;
  
  return all_match;
}

// ============================================================================
// CPU vs GPU Comparison Tests
// ============================================================================



// ============================================================================
// Main
// ============================================================================
int main(int argc, char* argv[]) {
  // Get Lebedev file path from command line or use default
  std::string leb_file;
  if (argc >= 2) {
    leb_file = argv[1];
  } else {
    leb_file = get_default_lebedev_path();
  }
  
  std::cout << "Running unit tests for intersection volume gradient computation..." << std::endl;
  std::cout << "Lebedev file: " << leb_file << std::endl;
  
  // Clear any previous CUDA errors
  cudaError_t err = cudaGetLastError();
  if (err != cudaSuccess && err != cudaErrorNoDevice) {
    cudaDeviceSynchronize();  // Clear error state
  }
  
  bool all_passed = true;
  
  // Phase 1: Test A(k) computation
  bool phase1_passed = test_phase1_Ak_computation();
  all_passed = all_passed && phase1_passed;
  if (!phase1_passed) {
    std::cout << "\nPhase 1 FAILED! Skipping subsequent tests." << std::endl;
    return 1;
  }
  
  // Phase 2: Test ∂A(k)/∂θ computation
  bool phase2_passed = test_phase2_Ak_gradient_computation();
  all_passed = all_passed && phase2_passed;
  if (!phase2_passed) {
    std::cout << "\nPhase 2 FAILED! Skipping subsequent tests." << std::endl;
    return 1;
  }
  
  // Phase 2 Advanced: Test ∂A(k)/∂θ computation over entire KGrid
  bool phase2_advanced_passed = test_phase2_Ak_gradient_computation_advanced(leb_file);
  all_passed = all_passed && phase2_advanced_passed;
  
  // Phase 3: Test intersection volume gradient (full pipeline)
  bool test_consistency_passed = test_intersection_volume_gradient_consistency(leb_file);
  all_passed = all_passed && test_consistency_passed;
  
  bool test_vol_consistency_triangles_passed = test_volume_consistency_triangles(leb_file);
  all_passed = all_passed && test_vol_consistency_triangles_passed;
  
  bool triangle_gradient_comprehensive_passed = test_triangle_gradient_comprehensive(leb_file);
  all_passed = all_passed && triangle_gradient_comprehensive_passed;
  
  // Disk/Point Cloud Tests
  // Phase 1: Test A(k) computation for disks
  bool phase1_disk_passed = test_phase1_Ak_computation_disk();
  all_passed = all_passed && phase1_disk_passed;
  
  // Phase 2: Test ∂A(k)/∂θ computation for disks
  bool phase2_disk_passed = test_phase2_Ak_gradient_computation_disk();
  all_passed = all_passed && phase2_disk_passed;
  
  // Phase 2 Advanced: Test ∂A(k)/∂θ computation over entire KGrid for disks
  bool phase2_advanced_disk_passed = test_phase2_Ak_gradient_computation_advanced_disk(leb_file);
  all_passed = all_passed && phase2_advanced_disk_passed;
  
  // Phase 3: Test intersection volume gradient (full pipeline)
  bool disk_gradient_comprehensive_passed = test_disk_gradient_comprehensive(leb_file);
  all_passed = all_passed && disk_gradient_comprehensive_passed;

  bool volume_consistency_disks_passed = test_volume_consistency_disks(leb_file);
  all_passed = all_passed && volume_consistency_disks_passed;
  
  // ============================================================================
  // Gaussian Splat Tests
  // ============================================================================
  
  // Phase 1: Test A(k) computation for Gaussian splats
  bool phase1_gaussian_passed = test_phase1_Ak_computation_gaussian();
  all_passed = all_passed && phase1_gaussian_passed;
  
  // Phase 2: Test ∂A(k)/∂θ computation for Gaussian splats
  bool phase2_gaussian_passed = test_phase2_Ak_gradient_computation_gaussian();
  all_passed = all_passed && phase2_gaussian_passed;
  
  // Phase 3: Test intersection volume gradient (full pipeline)
  bool gaussian_gradient_comprehensive_passed = test_gaussian_gradient_comprehensive(leb_file);
  all_passed = all_passed && gaussian_gradient_comprehensive_passed;
  
  bool volume_consistency_gaussians_passed = test_volume_consistency_gaussians(leb_file);
  all_passed = all_passed && volume_consistency_gaussians_passed;
  
  // Summary
  std::cout << "\n=== Summary ===" << std::endl;
  std::cout << "\n--- Triangle Mesh Tests ---" << std::endl;
  std::cout << "  Phase 1 (A(k) computation):           " << (phase1_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 2 (∂A(k)/∂θ computation):        " << (phase2_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 2 Advanced (Full KGrid):         " << (phase2_advanced_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.1 (Consistency):              " << (test_consistency_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.2 (Volume Consistency):       " << (test_vol_consistency_triangles_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.3 (Comprehensive):            " << (triangle_gradient_comprehensive_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "\n--- Disk/Point Cloud Tests ---" << std::endl;
  std::cout << "  Phase 1 (A(k) computation):            " << (phase1_disk_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 2 (∂A(k)/∂θ computation):        " << (phase2_disk_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 2 Advanced (Full KGrid):        " << (phase2_advanced_disk_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.1 (Comprehensive):            " << (disk_gradient_comprehensive_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.2 (Volume Consistency):       " << (volume_consistency_disks_passed ? "PASS" : "FAIL") << std::endl;
  
  std::cout << "\n--- Gaussian Splat Tests ---" << std::endl;
  std::cout << "  Phase 1 (A(k) computation):            " << (phase1_gaussian_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 2 (∂A(k)/∂θ computation):        " << (phase2_gaussian_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.1 (Comprehensive):            " << (gaussian_gradient_comprehensive_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "  Phase 3.2 (Volume Consistency):       " << (volume_consistency_gaussians_passed ? "PASS" : "FAIL") << std::endl;
  
  if (all_passed) {
    std::cout << "\nAll tests PASSED!" << std::endl;
    return 0;
  } else {
    std::cout << "\nSome tests FAILED!" << std::endl;
    return 1;
  }
}

