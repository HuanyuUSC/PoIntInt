#include <Eigen/Dense>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <chrono>
#include <vector>
#include <complex>
#include <cuda_runtime.h>
#include <string>
#include "test_config.h"  // Generated by CMake
#include "dof/affine_dof.hpp"
#include "geometry/packing.hpp"
#include "geometry/geometry_helpers.hpp"
#include "geometry/geometry.hpp"
#include "compute_intersection_volume.hpp"
#include "compute_volume.hpp"
#include "quadrature/lebedev_io.hpp"
#include "quadrature/kgrid.hpp"
#include "form_factor_helpers.hpp"

using namespace PoIntInt;

// Helper function to get the default Lebedev file path
std::string get_default_lebedev_path() {
#ifdef POINTINT_SOURCE_DIR
  std::string source_dir = POINTINT_SOURCE_DIR;
  // Convert to string and handle path separators
  for (size_t i = 0; i < source_dir.length(); ++i) {
    if (source_dir[i] == '\\') {
      source_dir[i] = '/';
    }
  }
  return source_dir + "/data/lebedev/lebedev_009.txt";
#else
  return "data/lebedev/lebedev_009.txt";
#endif
}

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ============================================================================
// Helper Functions
// ============================================================================

// Debug helper: Print detailed gradient component comparison
void debug_gradient_components(
  const Eigen::VectorXd& grad_cpu,
  const Eigen::VectorXd& grad_gpu,
  const Eigen::VectorXd& grad_fd,
  const std::string& label,
  int max_print = 12
) {
  std::cout << "    " << label << " component-by-component comparison:" << std::endl;
  std::cout << "      DoF |      CPU      |      GPU      |       FD      | CPU-GPU | GPU-FD | CPU-FD" << std::endl;
  std::cout << "      ----+--------------+--------------+--------------+---------+--------+--------" << std::endl;
  
  int num_printed = 0;
  double max_cpu_gpu = 0.0, max_gpu_fd = 0.0, max_cpu_fd = 0.0;
  int max_cpu_gpu_idx = -1, max_gpu_fd_idx = -1, max_cpu_fd_idx = -1;
  
  for (int i = 0; i < grad_cpu.size() && num_printed < max_print; ++i) {
    double cpu_val = grad_cpu(i);
    double gpu_val = grad_gpu(i);
    double fd_val = grad_fd(i);
    double err_cpu_gpu = std::abs(cpu_val - gpu_val);
    double err_gpu_fd = std::abs(gpu_val - fd_val);
    double err_cpu_fd = std::abs(cpu_val - fd_val);
    
    if (err_cpu_gpu > max_cpu_gpu) {
      max_cpu_gpu = err_cpu_gpu;
      max_cpu_gpu_idx = i;
    }
    if (err_gpu_fd > max_gpu_fd) {
      max_gpu_fd = err_gpu_fd;
      max_gpu_fd_idx = i;
    }
    if (err_cpu_fd > max_cpu_fd) {
      max_cpu_fd = err_cpu_fd;
      max_cpu_fd_idx = i;
    }
    
    // Print if error is significant
    if (err_cpu_gpu > 0.001 || err_gpu_fd > 0.001 || err_cpu_fd > 0.001) {
      std::cout << "      " << std::setw(3) << i << " | " 
                << std::setw(12) << std::setprecision(6) << cpu_val << " | "
                << std::setw(12) << gpu_val << " | "
                << std::setw(12) << fd_val << " | "
                << std::setw(7) << err_cpu_gpu << " | "
                << std::setw(6) << err_gpu_fd << " | "
                << std::setw(6) << err_cpu_fd << std::endl;
      num_printed++;
    }
  }
  
  if (num_printed == 0) {
    std::cout << "      (All components match within 0.001)" << std::endl;
  }
  
  std::cout << "      Max errors:" << std::endl;
  if (max_cpu_gpu_idx >= 0) {
    std::cout << "        CPU-GPU: DoF " << max_cpu_gpu_idx << " = " << max_cpu_gpu 
              << " (CPU: " << grad_cpu(max_cpu_gpu_idx) 
              << ", GPU: " << grad_gpu(max_cpu_gpu_idx) << ")" << std::endl;
  }
  if (max_gpu_fd_idx >= 0) {
    std::cout << "        GPU-FD:  DoF " << max_gpu_fd_idx << " = " << max_gpu_fd
              << " (GPU: " << grad_gpu(max_gpu_fd_idx) 
              << ", FD: " << grad_fd(max_gpu_fd_idx) << ")" << std::endl;
  }
  if (max_cpu_fd_idx >= 0) {
    std::cout << "        CPU-FD:  DoF " << max_cpu_fd_idx << " = " << max_cpu_fd
              << " (CPU: " << grad_cpu(max_cpu_fd_idx) 
              << ", FD: " << grad_fd(max_cpu_fd_idx) << ")" << std::endl;
  }
}

// Compute intersection volume gradient using finite differencing
std::pair<Eigen::VectorXd, Eigen::VectorXd> compute_intersection_volume_gradient_finite_diff(
  const Geometry& ref_geom1,
  const Geometry& ref_geom2,
  const std::shared_ptr<DoFParameterization>& dof1,
  const std::shared_ptr<DoFParameterization>& dof2,
  const Eigen::VectorXd& dofs1,
  const Eigen::VectorXd& dofs2,
  const KGrid& kgrid,
  double eps = 1e-2)
{
  int n_dofs1 = dof1->num_dofs();
  int n_dofs2 = dof2->num_dofs();
  Eigen::VectorXd grad1(n_dofs1);
  Eigen::VectorXd grad2(n_dofs2);
  
  // Gradient w.r.t. dofs1
  for (int i = 0; i < n_dofs1; ++i) {
    Eigen::VectorXd dofs1_p2 = dofs1;
    Eigen::VectorXd dofs1_p1 = dofs1;
    Eigen::VectorXd dofs1_m1 = dofs1;
    Eigen::VectorXd dofs1_m2 = dofs1;
    
    dofs1_p2(i) += 2.0 * eps;
    dofs1_p1(i) += eps;
    dofs1_m1(i) -= eps;
    dofs1_m2(i) -= 2.0 * eps;
    
    double vol_p2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_p2, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_p1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_p1, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_m1, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_m2, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    grad1(i) = (-vol_p2 + 8.0 * vol_p1 - 8.0 * vol_m1 + vol_m2) / (12.0 * eps);
  }
  
  // Gradient w.r.t. dofs2
  for (int i = 0; i < n_dofs2; ++i) {
    Eigen::VectorXd dofs2_p2 = dofs2;
    Eigen::VectorXd dofs2_p1 = dofs2;
    Eigen::VectorXd dofs2_m1 = dofs2;
    Eigen::VectorXd dofs2_m2 = dofs2;
    
    dofs2_p2(i) += 2.0 * eps;
    dofs2_p1(i) += eps;
    dofs2_m1(i) -= eps;
    dofs2_m2(i) -= 2.0 * eps;
    
    double vol_p2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_p2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_p1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_p1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_m1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_m2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    grad2(i) = (-vol_p2 + 8.0 * vol_p1 - 8.0 * vol_m1 + vol_m2) / (12.0 * eps);
  }
  
  return std::make_pair(grad1, grad2);
}

// ============================================================================
// Intersection Volume Tests
// ============================================================================
// Note: Self-volume tests are NOT included here. Self-volume unified interface
// is not yet implemented. Self-volume should be computed using the divergence
// theorem: V = (1/3) ∫_S (x, y, z) · n dS, which requires DoF-specific local
// contributions. This will be implemented in a future phase.
// ============================================================================

// Test intersection volume with different flags (triangles)
bool test_intersection_volume_flags_triangles(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Flags (Triangles) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += Eigen::RowVector3d(0.5, 0.0, 0.0);
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF with identity transformations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 32);
  
  // Test different flags
  std::cout << "  Testing VOLUME_ONLY..." << std::endl;
  auto result_vol = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  std::cout << "    Volume: " << std::setprecision(10) << result_vol.volume << std::endl;
  
  std::cout << "  Testing VOLUME_ONLY | GRADIENT..." << std::endl;
  auto result_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 
    256, false);
  std::cout << "    Volume: " << result_grad.volume << std::endl;
  std::cout << "    Gradient 1 norm: " << result_grad.grad_geom1.norm() << std::endl;
  std::cout << "    Gradient 2 norm: " << result_grad.grad_geom2.norm() << std::endl;
  
  std::cout << "  Testing ALL (VOLUME | GRADIENT | HESSIAN)..." << std::endl;
  auto result_all = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::ALL, 256, false);
  std::cout << "    Volume: " << result_all.volume << std::endl;
  std::cout << "    Gradient 1 norm: " << result_all.grad_geom1.norm() << std::endl;
  std::cout << "    Gradient 2 norm: " << result_all.grad_geom2.norm() << std::endl;
  std::cout << "    Hessian 11 norm: " << result_all.hessian_geom1.norm() << std::endl;
  std::cout << "    Hessian 22 norm: " << result_all.hessian_geom2.norm() << std::endl;
  std::cout << "    Hessian 12 norm: " << result_all.hessian_cross.norm() << std::endl;
  
  // Check consistency
  bool pass = true;
  if (std::abs(result_vol.volume - result_grad.volume) > 1e-10) {
    std::cout << "  ERROR: Volume mismatch between VOLUME_ONLY and GRADIENT flags!" << std::endl;
    pass = false;
  }
  if (std::abs(result_vol.volume - result_all.volume) > 1e-10) {
    std::cout << "  ERROR: Volume mismatch between VOLUME_ONLY and ALL flags!" << std::endl;
    pass = false;
  }
  
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  return pass;
}

// Test intersection volume CPU vs GPU and GPU vs finite differencing (triangles)
bool test_intersection_volume_triangles_comprehensive(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (Triangles) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += Eigen::RowVector3d(0.5, 0.0, 0.0);
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF with small translations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// ============================================================================
// Tests for Different Geometry Types
// ============================================================================

// Test intersection volume with disks (CPU vs GPU vs FD)
bool test_intersection_volume_disks(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (Disks) ===" << std::endl;
  
  // Create two unit sphere point clouds
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd radii1, radii2;
  create_sphere_pointcloud(P1, N1, radii1, 1000);
  create_sphere_pointcloud(P2, N2, radii2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation;
  }
  
  auto geom1 = make_point_cloud(P1, N1, radii1, true);
  auto geom2 = make_point_cloud(P2, N2, radii2, true);
  
  // Create AffineDoF with small translations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // Debug: Print component-by-component comparison if errors are large
  if (max_error1_gpu_fd > 0.01 || max_error2_gpu_fd > 0.01) {
    debug_gradient_components(result_cpu_grad.grad_geom1, result_gpu_grad.grad_geom1, grad_fd.first, "Geometry 1 (Disks)");
    debug_gradient_components(result_cpu_grad.grad_geom2, result_gpu_grad.grad_geom2, grad_fd.second, "Geometry 2 (Disks)");
  }
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// Test intersection volume with Gaussians (CPU vs GPU vs FD)
bool test_intersection_volume_gaussians(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (Gaussians) ===" << std::endl;
  
  // Create two unit sphere Gaussian splats
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd sigmas1, weights1, sigmas2, weights2;
  create_sphere_gaussians(P1, N1, sigmas1, weights1, 1000);
  create_sphere_gaussians(P2, N2, sigmas2, weights2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation;
  }
  
  auto geom1 = make_gaussian_splat(P1, N1, sigmas1, weights1);
  auto geom2 = make_gaussian_splat(P2, N2, sigmas2, weights2);
  
  // Create AffineDoF with small translations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // Debug: Print component-by-component comparison if errors are large
  if (max_error1_gpu_fd > 0.01 || max_error2_gpu_fd > 0.01) {
    debug_gradient_components(result_cpu_grad.grad_geom1, result_gpu_grad.grad_geom1, grad_fd.first, "Geometry 1 (Gaussians)");
    debug_gradient_components(result_cpu_grad.grad_geom2, result_gpu_grad.grad_geom2, grad_fd.second, "Geometry 2 (Gaussians)");
  }
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// ============================================================================
// Main Test Runner
// ============================================================================

int main(int argc, char* argv[]) {
  std::cout << "Running unit tests for unified volume interface..." << std::endl;
  
  // Get Lebedev file path
  std::string leb_file = get_default_lebedev_path();
  if (argc > 1) {
    leb_file = argv[1];
  }
  std::cout << "Lebedev file: " << leb_file << std::endl;
  
  int passed = 0;
  int total = 0;
  
  // Note: Self-volume tests are NOT included here. Self-volume unified interface
  // is not yet implemented. See DESIGN_PROPOSAL.md for details.
  
  // Intersection volume tests
  total++;
  if (test_intersection_volume_flags_triangles(leb_file)) passed++;
  
  total++;
  if (test_intersection_volume_triangles_comprehensive(leb_file)) passed++;
  
  // Different geometry types
  total++;
  if (test_intersection_volume_disks(leb_file)) passed++;
  
  total++;
  if (test_intersection_volume_gaussians(leb_file)) passed++;
  
  // Summary
  std::cout << "\n=== Summary ===" << std::endl;
  std::cout << "Passed: " << passed << " / " << total << std::endl;
  if (passed == total) {
    std::cout << "All tests PASSED!" << std::endl;
    return 0;
  } else {
    std::cout << "Some tests FAILED!" << std::endl;
    return 1;
  }
}

