#include <Eigen/Dense>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <chrono>
#include <vector>
#include <complex>
#include <cuda_runtime.h>
#include <string>
#include "test_config.h"  // Generated by CMake
#include "dof/affine_dof.hpp"
#include "dof/triangle_mesh_dof.hpp"
#include "geometry/packing.hpp"
#include "geometry/geometry_helpers.hpp"
#include "geometry/geometry.hpp"
#include "compute_intersection_volume.hpp"
#include "compute_intersection_volume_multi_object.hpp"
#include "compute_volume.hpp"
#include "quadrature/lebedev_io.hpp"
#include "quadrature/kgrid.hpp"
#include "form_factor_helpers.hpp"
#include "computation_flags.hpp"

using namespace PoIntInt;

// Helper function to get the default Lebedev file path
std::string get_default_lebedev_path() {
#ifdef POINTINT_SOURCE_DIR
  std::string source_dir = POINTINT_SOURCE_DIR;
  // Convert to string and handle path separators
  for (size_t i = 0; i < source_dir.length(); ++i) {
    if (source_dir[i] == '\\') {
      source_dir[i] = '/';
    }
  }
  return source_dir + "/data/lebedev/lebedev_009.txt";
#else
  return "data/lebedev/lebedev_009.txt";
#endif
}

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ============================================================================
// Helper Functions
// ============================================================================

// Debug helper: Print detailed gradient component comparison
void debug_gradient_components(
  const Eigen::VectorXd& grad_cpu,
  const Eigen::VectorXd& grad_gpu,
  const Eigen::VectorXd& grad_fd,
  const std::string& label,
  int max_print = 12
) {
  std::cout << "    " << label << " component-by-component comparison:" << std::endl;
  std::cout << "      DoF |      CPU      |      GPU      |       FD      | CPU-GPU | GPU-FD | CPU-FD" << std::endl;
  std::cout << "      ----+--------------+--------------+--------------+---------+--------+--------" << std::endl;
  
  int num_printed = 0;
  double max_cpu_gpu = 0.0, max_gpu_fd = 0.0, max_cpu_fd = 0.0;
  int max_cpu_gpu_idx = -1, max_gpu_fd_idx = -1, max_cpu_fd_idx = -1;
  
  for (int i = 0; i < grad_cpu.size() && num_printed < max_print; ++i) {
    double cpu_val = grad_cpu(i);
    double gpu_val = grad_gpu(i);
    double fd_val = grad_fd(i);
    double err_cpu_gpu = std::abs(cpu_val - gpu_val);
    double err_gpu_fd = std::abs(gpu_val - fd_val);
    double err_cpu_fd = std::abs(cpu_val - fd_val);
    
    if (err_cpu_gpu > max_cpu_gpu) {
      max_cpu_gpu = err_cpu_gpu;
      max_cpu_gpu_idx = i;
    }
    if (err_gpu_fd > max_gpu_fd) {
      max_gpu_fd = err_gpu_fd;
      max_gpu_fd_idx = i;
    }
    if (err_cpu_fd > max_cpu_fd) {
      max_cpu_fd = err_cpu_fd;
      max_cpu_fd_idx = i;
    }
    
    // Print if error is significant
    if (err_cpu_gpu > 0.001 || err_gpu_fd > 0.001 || err_cpu_fd > 0.001) {
      std::cout << "      " << std::setw(3) << i << " | " 
                << std::setw(12) << std::setprecision(6) << cpu_val << " | "
                << std::setw(12) << gpu_val << " | "
                << std::setw(12) << fd_val << " | "
                << std::setw(7) << err_cpu_gpu << " | "
                << std::setw(6) << err_gpu_fd << " | "
                << std::setw(6) << err_cpu_fd << std::endl;
      num_printed++;
    }
  }
  
  if (num_printed == 0) {
    std::cout << "      (All components match within 0.001)" << std::endl;
  }
  
  std::cout << "      Max errors:" << std::endl;
  if (max_cpu_gpu_idx >= 0) {
    std::cout << "        CPU-GPU: DoF " << max_cpu_gpu_idx << " = " << max_cpu_gpu 
              << " (CPU: " << grad_cpu(max_cpu_gpu_idx) 
              << ", GPU: " << grad_gpu(max_cpu_gpu_idx) << ")" << std::endl;
  }
  if (max_gpu_fd_idx >= 0) {
    std::cout << "        GPU-FD:  DoF " << max_gpu_fd_idx << " = " << max_gpu_fd
              << " (GPU: " << grad_gpu(max_gpu_fd_idx) 
              << ", FD: " << grad_fd(max_gpu_fd_idx) << ")" << std::endl;
  }
  if (max_cpu_fd_idx >= 0) {
    std::cout << "        CPU-FD:  DoF " << max_cpu_fd_idx << " = " << max_cpu_fd
              << " (CPU: " << grad_cpu(max_cpu_fd_idx) 
              << ", FD: " << grad_fd(max_cpu_fd_idx) << ")" << std::endl;
  }
}

// Compute intersection volume gradient using finite differencing
std::pair<Eigen::VectorXd, Eigen::VectorXd> compute_intersection_volume_gradient_finite_diff(
  const Geometry& ref_geom1,
  const Geometry& ref_geom2,
  const std::shared_ptr<DoFParameterization>& dof1,
  const std::shared_ptr<DoFParameterization>& dof2,
  const Eigen::VectorXd& dofs1,
  const Eigen::VectorXd& dofs2,
  const KGrid& kgrid,
  double eps = 1e-2)
{
  int n_dofs1 = dof1->num_dofs();
  int n_dofs2 = dof2->num_dofs();
  Eigen::VectorXd grad1(n_dofs1);
  Eigen::VectorXd grad2(n_dofs2);
  
  // Gradient w.r.t. dofs1
  for (int i = 0; i < n_dofs1; ++i) {
    Eigen::VectorXd dofs1_p2 = dofs1;
    Eigen::VectorXd dofs1_p1 = dofs1;
    Eigen::VectorXd dofs1_m1 = dofs1;
    Eigen::VectorXd dofs1_m2 = dofs1;
    
    dofs1_p2(i) += 2.0 * eps;
    dofs1_p1(i) += eps;
    dofs1_m1(i) -= eps;
    dofs1_m2(i) -= 2.0 * eps;
    
    double vol_p2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_p2, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_p1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_p1, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_m1, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1_m2, dofs2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    grad1(i) = (-vol_p2 + 8.0 * vol_p1 - 8.0 * vol_m1 + vol_m2) / (12.0 * eps);
  }
  
  // Gradient w.r.t. dofs2
  for (int i = 0; i < n_dofs2; ++i) {
    Eigen::VectorXd dofs2_p2 = dofs2;
    Eigen::VectorXd dofs2_p1 = dofs2;
    Eigen::VectorXd dofs2_m1 = dofs2;
    Eigen::VectorXd dofs2_m2 = dofs2;
    
    dofs2_p2(i) += 2.0 * eps;
    dofs2_p1(i) += eps;
    dofs2_m1(i) -= eps;
    dofs2_m2(i) -= 2.0 * eps;
    
    double vol_p2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_p2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_p1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_p1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m1 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_m1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    double vol_m2 = compute_intersection_volume_cuda(ref_geom1, ref_geom2, dof1, dof2, dofs1, dofs2_m2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume;
    
    grad2(i) = (-vol_p2 + 8.0 * vol_p1 - 8.0 * vol_m1 + vol_m2) / (12.0 * eps);
  }
  
  return std::make_pair(grad1, grad2);
}

// ============================================================================
// Intersection Volume Tests
// ============================================================================
// Note: Self-volume tests are NOT included here. Self-volume unified interface
// is not yet implemented. Self-volume should be computed using the divergence
// theorem: V = (1/3) ∫_S (x, y, z) · n dS, which requires DoF-specific local
// contributions. This will be implemented in a future phase.
// ============================================================================

// Test intersection volume with different flags (triangles)
bool test_intersection_volume_flags_triangles(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Flags (Triangles) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += Eigen::RowVector3d(0.5, 0.0, 0.0);
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF with identity transformations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 32);
  
  // Test different flags
  std::cout << "  Testing VOLUME_ONLY..." << std::endl;
  auto result_vol = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  std::cout << "    Volume: " << std::setprecision(10) << result_vol.volume << std::endl;
  
  std::cout << "  Testing VOLUME_ONLY | GRADIENT..." << std::endl;
  auto result_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 
    256, false);
  std::cout << "    Volume: " << result_grad.volume << std::endl;
  std::cout << "    Gradient 1 norm: " << result_grad.grad_geom1.norm() << std::endl;
  std::cout << "    Gradient 2 norm: " << result_grad.grad_geom2.norm() << std::endl;
  
  std::cout << "  Testing ALL (VOLUME | GRADIENT | HESSIAN)..." << std::endl;
  auto result_all = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::ALL, 256, false);
  std::cout << "    Volume: " << result_all.volume << std::endl;
  std::cout << "    Gradient 1 norm: " << result_all.grad_geom1.norm() << std::endl;
  std::cout << "    Gradient 2 norm: " << result_all.grad_geom2.norm() << std::endl;
  std::cout << "    Hessian 11 norm: " << result_all.hessian_geom1.norm() << std::endl;
  std::cout << "    Hessian 22 norm: " << result_all.hessian_geom2.norm() << std::endl;
  std::cout << "    Hessian 12 norm: " << result_all.hessian_cross.norm() << std::endl;
  
  // Check consistency
  bool pass = true;
  if (std::abs(result_vol.volume - result_grad.volume) > 1e-10) {
    std::cout << "  ERROR: Volume mismatch between VOLUME_ONLY and GRADIENT flags!" << std::endl;
    pass = false;
  }
  if (std::abs(result_vol.volume - result_all.volume) > 1e-10) {
    std::cout << "  ERROR: Volume mismatch between VOLUME_ONLY and ALL flags!" << std::endl;
    pass = false;
  }
  
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  return pass;
}

// Test intersection volume CPU vs GPU and GPU vs finite differencing (triangles)
bool test_intersection_volume_triangles_comprehensive(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (Triangles) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += Eigen::RowVector3d(0.5, 0.0, 0.0);
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF with small translations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// ============================================================================
// Tests for Different Geometry Types
// ============================================================================

// Test intersection volume with disks (CPU vs GPU vs FD)
bool test_intersection_volume_disks(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (Disks) ===" << std::endl;
  
  // Create two unit sphere point clouds
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd radii1, radii2;
  create_sphere_pointcloud(P1, N1, radii1, 1000);
  create_sphere_pointcloud(P2, N2, radii2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation;
  }
  
  auto geom1 = make_point_cloud(P1, N1, radii1, true);
  auto geom2 = make_point_cloud(P2, N2, radii2, true);
  
  // Create AffineDoF with small translations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // Debug: Print component-by-component comparison if errors are large
  if (max_error1_gpu_fd > 0.01 || max_error2_gpu_fd > 0.01) {
    debug_gradient_components(result_cpu_grad.grad_geom1, result_gpu_grad.grad_geom1, grad_fd.first, "Geometry 1 (Disks)");
    debug_gradient_components(result_cpu_grad.grad_geom2, result_gpu_grad.grad_geom2, grad_fd.second, "Geometry 2 (Disks)");
  }
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// Test intersection volume with Gaussians (CPU vs GPU vs FD)
bool test_intersection_volume_gaussians(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (Gaussians) ===" << std::endl;
  
  // Create two unit sphere Gaussian splats
  Eigen::MatrixXd P1, N1, P2, N2;
  Eigen::VectorXd sigmas1, weights1, sigmas2, weights2;
  create_sphere_gaussians(P1, N1, sigmas1, weights1, 1000);
  create_sphere_gaussians(P2, N2, sigmas2, weights2, 1000);
  
  // Translate second sphere
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation;
  }
  
  auto geom1 = make_gaussian_splat(P1, N1, sigmas1, weights1);
  auto geom2 = make_gaussian_splat(P2, N2, sigmas2, weights2);
  
  // Create AffineDoF with small translations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // Debug: Print component-by-component comparison if errors are large
  if (max_error1_gpu_fd > 0.01 || max_error2_gpu_fd > 0.01) {
    debug_gradient_components(result_cpu_grad.grad_geom1, result_gpu_grad.grad_geom1, grad_fd.first, "Geometry 1 (Gaussians)");
    debug_gradient_components(result_cpu_grad.grad_geom2, result_gpu_grad.grad_geom2, grad_fd.second, "Geometry 2 (Gaussians)");
  }
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// Test intersection volume with TriangleMeshDoF (CPU vs GPU vs FD)
bool test_intersection_volume_triangle_mesh_dof(const std::string& leb_file) {
  std::cout << "\n=== Test: Intersection Volume Comprehensive (TriangleMeshDoF) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube slightly
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += Eigen::RowVector3d(0.5, 0.0, 0.0);
  }
  
  // Apply small perturbations to vertex positions for testing
  Eigen::MatrixXd V1_perturbed = V1;
  Eigen::MatrixXd V2_perturbed = V2;
  for (int i = 0; i < V1_perturbed.rows(); ++i) {
    V1_perturbed.row(i) += Eigen::RowVector3d(0.1, 0.0, 0.0);
  }
  for (int i = 0; i < V2_perturbed.rows(); ++i) {
    V2_perturbed.row(i) += Eigen::RowVector3d(0.0, 0.1, 0.0);
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create TriangleMeshDoF objects (face connectivity is extracted from geometry)
  auto mesh_dof1 = std::make_shared<TriangleMeshDoF>(V1.rows());
  auto mesh_dof2 = std::make_shared<TriangleMeshDoF>(V2.rows());
  
  // Set up DoFs as flattened vertex positions
  Eigen::VectorXd dofs1(V1_perturbed.rows() * 3);
  Eigen::VectorXd dofs2(V2_perturbed.rows() * 3);
  for (int i = 0; i < V1_perturbed.rows(); ++i) {
    dofs1(i * 3 + 0) = V1_perturbed(i, 0);
    dofs1(i * 3 + 1) = V1_perturbed(i, 1);
    dofs1(i * 3 + 2) = V1_perturbed(i, 2);
  }
  for (int i = 0; i < V2_perturbed.rows(); ++i) {
    dofs2(i * 3 + 0) = V2_perturbed(i, 0);
    dofs2(i * 3 + 1) = V2_perturbed(i, 1);
    dofs2(i * 3 + 2) = V2_perturbed(i, 2);
  }
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU ==========
  std::cout << "  Part 1: CPU vs GPU..." << std::endl;
  
  // Test VOLUME_ONLY
  std::cout << "    Testing VOLUME_ONLY..." << std::endl;
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_cpu(geom1, geom2, mesh_dof1, mesh_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_cuda(geom1, geom2, mesh_dof1, mesh_dof2, dofs1, dofs2, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double vol_error = std::abs(result_cpu.volume - result_gpu.volume);
  double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume), 1e-10);
  
  std::cout << "      CPU volume: " << std::setprecision(10) << result_cpu.volume << std::endl;
  std::cout << "      GPU volume: " << result_gpu.volume << std::endl;
  std::cout << "      Absolute error: " << vol_error << std::endl;
  std::cout << "      Relative error: " << vol_rel_error << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Test GRADIENT
  std::cout << "    Testing GRADIENT..." << std::endl;
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_cpu(geom1, geom2, mesh_dof1, mesh_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_cuda(geom1, geom2, mesh_dof1, mesh_dof2, dofs1, dofs2, KG, 
    static_cast<ComputationFlags>(static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT)), 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double grad1_error_cpu_gpu = (result_cpu_grad.grad_geom1 - result_gpu_grad.grad_geom1).norm();
  double grad2_error_cpu_gpu = (result_cpu_grad.grad_geom2 - result_gpu_grad.grad_geom2).norm();
  std::cout << "      CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "      Gradient 1 error: " << grad1_error_cpu_gpu << std::endl;
  std::cout << "      CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "      Gradient 2 error: " << grad2_error_cpu_gpu << std::endl;
  std::cout << "      CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "      GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "      Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: GPU vs Finite Differencing ==========
  std::cout << "  Part 2: GPU vs Finite Differencing..." << std::endl;
  
  // First, check that volume computation is consistent
  auto result_vol_only = compute_intersection_volume_cuda(geom1, geom2, mesh_dof1, mesh_dof2, dofs1, dofs2, KG, 
    ComputationFlags::VOLUME_ONLY, 256, false);
  
  // Check volume consistency
  double vol_diff = std::abs(result_vol_only.volume - result_gpu_grad.volume);
  double vol_rel_error_consistency = vol_diff / std::max(std::abs(result_vol_only.volume), 1e-10);
  std::cout << "    Volume (VOLUME_ONLY): " << result_vol_only.volume << std::endl;
  std::cout << "    Volume (GRADIENT): " << result_gpu_grad.volume << std::endl;
  std::cout << "    Volume difference: " << vol_diff << " (rel: " << vol_rel_error_consistency << ")" << std::endl;
  
  // Compute gradient using finite differencing
  auto grad_fd = compute_intersection_volume_gradient_finite_diff(geom1, geom2, mesh_dof1, mesh_dof2, dofs1, dofs2, KG, 1e-5);
  
  // Compare GPU gradient with finite differencing
  double error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_gpu_fd = (result_gpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_gpu_fd = (result_gpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    GPU gradient 1 norm: " << result_gpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_gpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_gpu_fd << std::endl;
  std::cout << "    GPU gradient 2 norm: " << result_gpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_gpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_gpu_fd << std::endl;
  
  // Debug: Print component-by-component comparison if errors are large
  if (max_error1_gpu_fd > 0.01 || max_error2_gpu_fd > 0.01) {
    debug_gradient_components(result_cpu_grad.grad_geom1, result_gpu_grad.grad_geom1, grad_fd.first, "Geometry 1 (TriangleMeshDoF)");
    debug_gradient_components(result_cpu_grad.grad_geom2, result_gpu_grad.grad_geom2, grad_fd.second, "Geometry 2 (TriangleMeshDoF)");
  }
  
  // ========== Part 3: CPU vs Finite Differencing ==========
  std::cout << "  Part 3: CPU vs Finite Differencing..." << std::endl;
  
  // Compare CPU gradient with finite differencing
  double error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).norm();
  double error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).norm();
  double max_error1_cpu_fd = (result_cpu_grad.grad_geom1 - grad_fd.first).cwiseAbs().maxCoeff();
  double max_error2_cpu_fd = (result_cpu_grad.grad_geom2 - grad_fd.second).cwiseAbs().maxCoeff();
  
  std::cout << "    CPU gradient 1 norm: " << result_cpu_grad.grad_geom1.norm() << std::endl;
  std::cout << "    FD gradient 1 norm: " << grad_fd.first.norm() << std::endl;
  std::cout << "    Gradient 1 error (norm): " << error1_cpu_fd << std::endl;
  std::cout << "    Max component error 1: " << max_error1_cpu_fd << std::endl;
  std::cout << "    CPU gradient 2 norm: " << result_cpu_grad.grad_geom2.norm() << std::endl;
  std::cout << "    FD gradient 2 norm: " << grad_fd.second.norm() << std::endl;
  std::cout << "    Gradient 2 error (norm): " << error2_cpu_fd << std::endl;
  std::cout << "    Max component error 2: " << max_error2_cpu_fd << std::endl;
  
  // Overall pass/fail
  bool pass_vol = vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = (grad1_error_cpu_gpu < 1e-6) && (grad2_error_cpu_gpu < 1e-6);
  bool pass_grad_gpu_fd = (max_error1_gpu_fd < 0.01) && (max_error2_gpu_fd < 0.01);
  bool pass_grad_cpu_fd = (max_error1_cpu_fd < 0.01) && (max_error2_cpu_fd < 0.01);
  bool pass_vol_consistency = vol_rel_error_consistency < 1e-6;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_vol_consistency;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume CPU vs GPU failed" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed" << std::endl;
    if (!pass_vol_consistency) std::cout << "      - Volume consistency failed" << std::endl;
  }
  return pass;
}

// ============================================================================
// Multi-Object Tests
// ============================================================================

// Compute gradient of volume matrix entry V[i,j] w.r.t. DoFs of object i using finite differencing
Eigen::VectorXd compute_volume_matrix_gradient_finite_diff_i(
  const std::vector<Geometry>& ref_geometries,
  const std::vector<std::shared_ptr<DoFParameterization>>& dofs,
  std::vector<Eigen::VectorXd> dof_vectors,
  const KGrid& kgrid,
  int i,
  int j,
  double eps = 1e-5)
{
  int n_dofs_i = dofs[i]->num_dofs();
  Eigen::VectorXd grad_i(n_dofs_i);
  
  // Compute gradient using 5-point stencil
  for (int dof_idx = 0; dof_idx < n_dofs_i; ++dof_idx) {
    std::vector<Eigen::VectorXd> dof_vectors_p2 = dof_vectors;
    std::vector<Eigen::VectorXd> dof_vectors_p1 = dof_vectors;
    std::vector<Eigen::VectorXd> dof_vectors_m1 = dof_vectors;
    std::vector<Eigen::VectorXd> dof_vectors_m2 = dof_vectors;
    
    dof_vectors_p2[i](dof_idx) += 2.0 * eps;
    dof_vectors_p1[i](dof_idx) += eps;
    dof_vectors_m1[i](dof_idx) -= eps;
    dof_vectors_m2[i](dof_idx) -= 2.0 * eps;
    
    double V_p2 = compute_intersection_volume_matrix_cuda(
      ref_geometries, dofs, dof_vectors_p2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume_matrix(i, j);
    double V_p1 = compute_intersection_volume_matrix_cuda(
      ref_geometries, dofs, dof_vectors_p1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume_matrix(i, j);
    double V_m1 = compute_intersection_volume_matrix_cuda(
      ref_geometries, dofs, dof_vectors_m1, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume_matrix(i, j);
    double V_m2 = compute_intersection_volume_matrix_cuda(
      ref_geometries, dofs, dof_vectors_m2, kgrid, ComputationFlags::VOLUME_ONLY, 256, false).volume_matrix(i, j);
    
    grad_i(dof_idx) = (-V_p2 + 8.0 * V_p1 - 8.0 * V_m1 + V_m2) / (12.0 * eps);
  }
  
  return grad_i;
}

// Test multi-object intersection volume matrix (CPU vs GPU vs FD)
bool test_multi_object_intersection_volume_comprehensive(const std::string& leb_file) {
  std::cout << "\n=== Test: Multi-Object Intersection Volume Comprehensive ===" << std::endl;
  
  // Create geometries: 1 mesh, 1 point cloud, 1 Gaussian splat
  std::vector<Geometry> geometries;
  std::vector<std::shared_ptr<DoFParameterization>> dofs;
  std::vector<Eigen::VectorXd> dof_vectors;
  
  // Object 0: Unit cube mesh
  Eigen::MatrixXd V1;
  Eigen::MatrixXi F1;
  create_unit_cube_mesh(V1, F1);
  geometries.push_back(make_triangle_mesh(V1, F1));
  dofs.push_back(std::make_shared<AffineDoF>());
  Eigen::VectorXd dofs0(12);
  dofs0 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dof_vectors.push_back(dofs0);
  
  // Object 1: Unit sphere point cloud
  Eigen::MatrixXd P1, N1;
  Eigen::VectorXd radii1;
  create_sphere_pointcloud(P1, N1, radii1, 500);
  // Translate sphere
  Eigen::Vector3d translation1(0.5, 0.0, 0.0);
  for (int i = 0; i < P1.rows(); ++i) {
    P1.row(i) += translation1;
  }
  geometries.push_back(make_point_cloud(P1, N1, radii1, true));
  dofs.push_back(std::make_shared<AffineDoF>());
  Eigen::VectorXd dofs1(12);
  dofs1 << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dof_vectors.push_back(dofs1);
  
  // Object 2: Unit sphere Gaussian splat
  Eigen::MatrixXd P2, N2;
  Eigen::VectorXd sigmas2, weights2;
  create_sphere_gaussians(P2, N2, sigmas2, weights2, 500);
  // Translate Gaussian splat
  Eigen::Vector3d translation2(0.0, 0.5, 0.0);
  for (int i = 0; i < P2.rows(); ++i) {
    P2.row(i) += translation2;
  }
  geometries.push_back(make_gaussian_splat(P2, N2, sigmas2, weights2));
  dofs.push_back(std::make_shared<AffineDoF>());
  Eigen::VectorXd dofs2(12);
  dofs2 << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dof_vectors.push_back(dofs2);
  
  int num_objects = 3;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 16);
  
  // ========== Part 1: CPU vs GPU (Volume Matrix) ==========
  std::cout << "  Part 1: CPU vs GPU (Volume Matrix)..." << std::endl;
  
  auto t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu = compute_intersection_volume_matrix_cpu(
    geometries, dofs, dof_vectors, KG, ComputationFlags::VOLUME_ONLY, false);
  auto t_cpu_end = std::chrono::high_resolution_clock::now();
  double cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  auto t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu = compute_intersection_volume_matrix_cuda(
    geometries, dofs, dof_vectors, KG, ComputationFlags::VOLUME_ONLY, 256, false);
  auto t_gpu_end = std::chrono::high_resolution_clock::now();
  double gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  // Compare volume matrices
  double max_vol_error = 0.0;
  double max_vol_rel_error = 0.0;
  for (int i = 0; i < num_objects; ++i) {
    for (int j = 0; j < num_objects; ++j) {
      double vol_error = std::abs(result_cpu.volume_matrix(i, j) - result_gpu.volume_matrix(i, j));
      double vol_rel_error = vol_error / std::max(std::abs(result_cpu.volume_matrix(i, j)), 1e-10);
      max_vol_error = std::max(max_vol_error, vol_error);
      max_vol_rel_error = std::max(max_vol_rel_error, vol_rel_error);
    }
  }
  
  std::cout << "    CPU volume matrix:" << std::endl;
  std::cout << result_cpu.volume_matrix << std::endl;
  std::cout << "    GPU volume matrix:" << std::endl;
  std::cout << result_gpu.volume_matrix << std::endl;
  std::cout << "    Max absolute error: " << max_vol_error << std::endl;
  std::cout << "    Max relative error: " << max_vol_rel_error << std::endl;
  std::cout << "    CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "    GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "    Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 2: CPU vs GPU (Gradients) ==========
  std::cout << "  Part 2: CPU vs GPU (Gradients)..." << std::endl;
  
  ComputationFlags grad_flags = static_cast<ComputationFlags>(
    static_cast<int>(ComputationFlags::VOLUME_ONLY) | static_cast<int>(ComputationFlags::GRADIENT));
  
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_grad = compute_intersection_volume_matrix_cpu(
    geometries, dofs, dof_vectors, KG, grad_flags, false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_grad = compute_intersection_volume_matrix_cuda(
    geometries, dofs, dof_vectors, KG, grad_flags, 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  // Compare gradients
  double max_grad_error = 0.0;
  for (int i = 0; i < num_objects; ++i) {
    for (int j = 0; j < num_objects; ++j) {
      if (!result_cpu_grad.grad_matrix.empty() && !result_gpu_grad.grad_matrix.empty()) {
        double grad_error = (result_cpu_grad.grad_matrix[i][j] - result_gpu_grad.grad_matrix[i][j]).norm();
        max_grad_error = std::max(max_grad_error, grad_error);
      }
    }
  }
  
  std::cout << "    Max gradient error (CPU vs GPU): " << max_grad_error << std::endl;
  std::cout << "    CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "    GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "    Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // ========== Part 3: GPU vs Finite Differencing (Gradients) ==========
  std::cout << "  Part 3: GPU vs Finite Differencing (Gradients)..." << std::endl;
  std::cout << "    Computing finite difference gradients (this may take a while)..." << std::endl;
  
  // Test a few key pairs to avoid excessive computation
  std::vector<std::pair<int, int>> test_pairs = {{0, 1}, {0, 2}, {1, 2}, {0, 0}, {1, 1}, {2, 2}};
  
  double max_grad_fd_error = 0.0;
  int num_tested = 0;
  
  for (const auto& pair : test_pairs) {
    int i = pair.first;
    int j = pair.second;
    
    if (result_gpu_grad.grad_matrix.empty() || result_gpu_grad.grad_matrix[i].empty()) {
      continue;
    }
    
    // Compute finite difference gradient w.r.t. DoFs of object i
    Eigen::VectorXd grad_fd_i = compute_volume_matrix_gradient_finite_diff_i(
      geometries, dofs, dof_vectors, KG, i, j, 1e-5);
    
    // For diagonal entries, V[i,i] gradient is 2 * grad_matrix[i][i]
    Eigen::VectorXd grad_gpu_effective = (i == j)
      ? 2.0 * result_gpu_grad.grad_matrix[i][j]
      : result_gpu_grad.grad_matrix[i][j];
    
    // Compare with GPU gradient
    double grad_error_i = (grad_gpu_effective - grad_fd_i).norm();
    double max_component_error_i = (grad_gpu_effective - grad_fd_i).cwiseAbs().maxCoeff();
    
    std::cout << "    Pair (" << i << "," << j << ") - Gradient w.r.t. object " << i << ":" << std::endl;
    std::cout << "      GPU norm (effective): " << grad_gpu_effective.norm() << std::endl;
    std::cout << "      FD norm: " << grad_fd_i.norm() << std::endl;
    std::cout << "      Error (norm): " << grad_error_i << std::endl;
    std::cout << "      Max component error: " << max_component_error_i << std::endl;
    
    max_grad_fd_error = std::max(max_grad_fd_error, max_component_error_i);
    num_tested++;
  }
  
  std::cout << "    Tested " << num_tested << " gradient pairs" << std::endl;
  std::cout << "    Max component error (GPU vs FD): " << max_grad_fd_error << std::endl;
  
  // ========== Part 4: CPU vs Finite Differencing (Gradients) ==========
  std::cout << "  Part 4: CPU vs Finite Differencing (Gradients)..." << std::endl;
  
  double max_grad_cpu_fd_error = 0.0;
  
  for (const auto& pair : test_pairs) {
    int i = pair.first;
    int j = pair.second;
    
    if (result_cpu_grad.grad_matrix.empty() || result_cpu_grad.grad_matrix[i].empty()) {
      continue;
    }
    
    // Compute finite difference gradient w.r.t. DoFs of object i
    Eigen::VectorXd grad_fd_i = compute_volume_matrix_gradient_finite_diff_i(
      geometries, dofs, dof_vectors, KG, i, j, 1e-5);
    
    // Compare with CPU gradient
    Eigen::VectorXd grad_cpu_effective = (i == j)
      ? 2.0 * result_cpu_grad.grad_matrix[i][j]
      : result_cpu_grad.grad_matrix[i][j];
    
    double grad_error_i = (grad_cpu_effective - grad_fd_i).norm();
    double max_component_error_i = (grad_cpu_effective - grad_fd_i).cwiseAbs().maxCoeff();
    
    std::cout << "    Pair (" << i << "," << j << ") - Gradient w.r.t. object " << i << ":" << std::endl;
    std::cout << "      CPU norm (effective): " << grad_cpu_effective.norm() << std::endl;
    std::cout << "      FD norm: " << grad_fd_i.norm() << std::endl;
    std::cout << "      Error (norm): " << grad_error_i << std::endl;
    std::cout << "      Max component error: " << max_component_error_i << std::endl;
    
    max_grad_cpu_fd_error = std::max(max_grad_cpu_fd_error, max_component_error_i);
  }
  
  std::cout << "    Max component error (CPU vs FD): " << max_grad_cpu_fd_error << std::endl;
  
  // ========== Part 5: CPU vs GPU (Hessians) ==========
  std::cout << "  Part 5: CPU vs GPU (Hessians)..." << std::endl;
  
  ComputationFlags hess_flags = ComputationFlags::ALL;
  
  t_cpu_start = std::chrono::high_resolution_clock::now();
  auto result_cpu_hess = compute_intersection_volume_matrix_cpu(
    geometries, dofs, dof_vectors, KG, hess_flags, false);
  t_cpu_end = std::chrono::high_resolution_clock::now();
  cpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_cpu_end - t_cpu_start).count() / 1000.0;
  
  t_gpu_start = std::chrono::high_resolution_clock::now();
  auto result_gpu_hess = compute_intersection_volume_matrix_cuda(
    geometries, dofs, dof_vectors, KG, hess_flags, 256, false);
  t_gpu_end = std::chrono::high_resolution_clock::now();
  gpu_time = std::chrono::duration_cast<std::chrono::microseconds>(t_gpu_end - t_gpu_start).count() / 1000.0;
  
  double max_hessian_error = 0.0;
  for (int i = 0; i < num_objects; ++i) {
    for (int j = 0; j < num_objects; ++j) {
      if (!result_cpu_hess.hessian_ij.empty() && !result_gpu_hess.hessian_ij.empty()) {
        Eigen::MatrixXd diff_ij = result_cpu_hess.hessian_ij[i][j] - result_gpu_hess.hessian_ij[i][j];
        double error_norm = diff_ij.norm();
        max_hessian_error = std::max(max_hessian_error, error_norm);
      }
      // hessian_ii and hessian_jj should both be zero for Gauss-Newton
      double cpu_hii_norm = result_cpu_hess.hessian_ii[i][j].norm();
      double gpu_hii_norm = result_gpu_hess.hessian_ii[i][j].norm();
      double cpu_hjj_norm = result_cpu_hess.hessian_jj[i][j].norm();
      double gpu_hjj_norm = result_gpu_hess.hessian_jj[i][j].norm();
      if (cpu_hii_norm > 1e-9 || gpu_hii_norm > 1e-9 ||
          cpu_hjj_norm > 1e-9 || gpu_hjj_norm > 1e-9) {
        std::cout << "    Warning: Non-zero diagonal Hessian detected at (" << i << "," << j << ")" << std::endl;
        std::cout << "      CPU H_ii norm: " << cpu_hii_norm << ", GPU H_ii norm: " << gpu_hii_norm << std::endl;
        std::cout << "      CPU H_jj norm: " << cpu_hjj_norm << ", GPU H_jj norm: " << gpu_hjj_norm << std::endl;
      }
    }
  }
  
  std::cout << "    Max Hessian cross-term error (CPU vs GPU): " << max_hessian_error << std::endl;
  std::cout << "    CPU time: " << cpu_time << " ms" << std::endl;
  std::cout << "    GPU time: " << gpu_time << " ms" << std::endl;
  std::cout << "    Speedup: " << (cpu_time / std::max(gpu_time, 0.001)) << "x" << std::endl;
  
  // Overall pass/fail
  bool pass_vol = max_vol_rel_error < 1e-6;
  bool pass_grad_cpu_gpu = max_grad_error < 1e-6;
  bool pass_grad_gpu_fd = max_grad_fd_error < 0.01;
  bool pass_grad_cpu_fd = max_grad_cpu_fd_error < 0.01;
  bool pass_hessian_cpu_gpu = max_hessian_error < 1e-5;
  
  bool pass = pass_vol && pass_grad_cpu_gpu && pass_grad_gpu_fd && pass_grad_cpu_fd && pass_hessian_cpu_gpu;
  std::cout << "  Result: " << (pass ? "PASS" : "FAIL") << std::endl;
  if (!pass) {
    std::cout << "    Details:" << std::endl;
    if (!pass_vol) std::cout << "      - Volume matrix CPU vs GPU failed (max rel error: " << max_vol_rel_error << ")" << std::endl;
    if (!pass_grad_cpu_gpu) std::cout << "      - Gradient CPU vs GPU failed (max error: " << max_grad_error << ")" << std::endl;
    if (!pass_grad_gpu_fd) std::cout << "      - Gradient GPU vs FD failed (max error: " << max_grad_fd_error << ")" << std::endl;
    if (!pass_grad_cpu_fd) std::cout << "      - Gradient CPU vs FD failed (max error: " << max_grad_cpu_fd_error << ")" << std::endl;
    if (!pass_hessian_cpu_gpu) std::cout << "      - Hessian CPU vs GPU failed (max error: " << max_hessian_error << ")" << std::endl;
  }
  return pass;
}

// ============================================================================
// Main Test Runner
// ============================================================================

int main(int argc, char* argv[]) {
  std::cout << "Running unit tests for unified volume interface..." << std::endl;
  
  // Get Lebedev file path
  std::string leb_file = get_default_lebedev_path();
  if (argc > 1) {
    leb_file = argv[1];
  }
  std::cout << "Lebedev file: " << leb_file << std::endl;
  
  int passed = 0;
  int total = 0;
  
  // Note: Self-volume tests are NOT included here. Self-volume unified interface
  // is not yet implemented. See DESIGN_PROPOSAL.md for details.
  
  // Intersection volume tests
  total++;
  if (test_intersection_volume_flags_triangles(leb_file)) passed++;
  
  total++;
  if (test_intersection_volume_triangles_comprehensive(leb_file)) passed++;
  
  // Different geometry types
  total++;
  if (test_intersection_volume_disks(leb_file)) passed++;
  
  total++;
  if (test_intersection_volume_gaussians(leb_file)) passed++;
  
  // TriangleMeshDoF test
  total++;
  if (test_intersection_volume_triangle_mesh_dof(leb_file)) passed++;
  
  // Multi-object test
  total++;
  if (test_multi_object_intersection_volume_comprehensive(leb_file)) passed++;
  
  // Summary
  std::cout << "\n=== Summary ===" << std::endl;
  std::cout << "Passed: " << passed << " / " << total << std::endl;
  if (passed == total) {
    std::cout << "All tests PASSED!" << std::endl;
    return 0;
  } else {
    std::cout << "Some tests FAILED!" << std::endl;
    return 1;
  }
}

