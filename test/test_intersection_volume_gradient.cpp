#include <Eigen/Dense>
#include <iostream>
#include <iomanip>
#include <cmath>
#include <vector>
#include <complex>
#include <cuda_runtime.h>
#include <string>
#include "test_config.h"  // Generated by CMake
#include "dof/affine_dof.hpp"
#include "geometry/packing.hpp"
#include "geometry/geometry_helpers.hpp"
#include "compute_intersection_volume.hpp"
#include "compute_intersection_volume_gradient.hpp"
#include "quadrature/lebedev_io.hpp"
#include "quadrature/kgrid.hpp"
#include "form_factor_helpers.hpp"

using namespace PoIntInt;

// Helper function to get the default Lebedev file path
std::string get_default_lebedev_path() {
#ifdef POINTINT_SOURCE_DIR
  std::string source_dir = POINTINT_SOURCE_DIR;
  // Convert to string and handle path separators
  // Use forward slashes (work on both Windows and Unix)
  std::string path = source_dir;
  // Replace backslashes with forward slashes for cross-platform compatibility
  for (size_t i = 0; i < path.length(); ++i) {
    if (path[i] == '\\') {
      path[i] = '/';
    }
  }
  return path + "/data/lebedev/lebedev_003.txt";
#else
  // Fallback if macro not defined
  return "data/lebedev/lebedev_131.txt";
#endif
}

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ============================================================================
// Phase 1: Test A(k) computation
// ============================================================================

bool test_phase1_Ak_computation() {
  std::cout << "\n=== Phase 1 Test: A(k) Computation ===" << std::endl;
  
  // Create unit cube mesh
  Eigen::MatrixXd V;
  Eigen::MatrixXi F;
  create_unit_cube_mesh(V, F);
  auto geom = make_triangle_mesh(V, F);
  
  // Create AffineDoF with identity transformation
  auto affine_dof = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.1, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(0.0, 0.0, 2.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 1.0),
  };
  
  double max_error_cpu = 0.0;
  double max_error_analytical = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& k : test_k_vectors) {
    // Compute A(k) using CUDA
    std::complex<double> Ak_cuda = compute_Ak_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute A(k) using CPU
    std::complex<double> Ak_cpu = affine_dof->compute_A(geom, k, dofs);
    
    // Compute analytical ground truth (for unit cube at origin)
    // For a unit cube centered at origin: A(k) = i*k * F(k) where F(k) is the form factor
    double kx = k.x(), ky = k.y(), kz = k.z();
    double kmag = k.norm();
    if (kmag < 1e-10) continue;
    
    // Form factor: F(k) = sinc(kx/2) * sinc(ky/2) * sinc(kz/2)
    auto sinc = [](double x) {
      if (std::abs(x) < 1e-4) return 1.0 - x*x/6.0;
      return std::sin(x) / x;
    };
    double F = sinc(0.5*kx) * sinc(0.5*ky) * sinc(0.5*kz);
    
    // A(k) = i*k * F(k) = i * (k·khat) * F(k) where khat = k/|k|
    // Actually, A_parallel(k) = (k·A(k))/|k|, and for a cube, A(k) = i*k*F(k)
    // So A_parallel(k) = i*|k|*F(k)
    std::complex<double> Ak_analytical = std::complex<double>(0.0, 1.0) * kmag * F;
    
    // Compare CUDA vs CPU
    std::complex<double> diff_cpu = Ak_cuda - Ak_cpu;
    double error_cpu = std::abs(diff_cpu) / std::max(std::abs(Ak_cuda), std::abs(Ak_cpu));
    if (error_cpu > max_error_cpu) max_error_cpu = error_cpu;
    
    // Compare CUDA vs Analytical
    std::complex<double> diff_analytical = Ak_cuda - Ak_analytical;
    double error_analytical = std::abs(diff_analytical) / std::max(std::abs(Ak_cuda), std::abs(Ak_analytical));
    if (error_analytical > max_error_analytical) max_error_analytical = error_analytical;
    
    if ((error_cpu > 0.01 || error_analytical > 0.1) && num_warnings < 5) {
      std::cout << "  k = (" << kx << ", " << ky << ", " << kz << "), |k| = " << kmag << ":" << std::endl;
      std::cout << "    CUDA:       " << Ak_cuda << std::endl;
      std::cout << "    CPU:        " << Ak_cpu << std::endl;
      std::cout << "    Analytical: " << Ak_analytical << std::endl;
      std::cout << "    Error (CUDA vs CPU): " << error_cpu << std::endl;
      std::cout << "    Error (CUDA vs Analytical): " << error_analytical << std::endl;
      num_warnings++;
    }
    
    num_tested++;
  }
  
  std::cout << "  Tested " << num_tested << " k-vectors" << std::endl;
  std::cout << "  Max error (CUDA vs CPU): " << max_error_cpu << std::endl;
  std::cout << "  Max error (CUDA vs Analytical): " << max_error_analytical << std::endl;
  
  bool passed = (max_error_cpu < 0.05) && (max_error_analytical < 0.2);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 2: Test ∂A(k)/∂θ computation
// ============================================================================

bool test_phase2_Ak_gradient_computation() {
  std::cout << "\n=== Phase 2 Test: ∂A(k)/∂θ Computation ===" << std::endl;
  
  // Create unit cube mesh
  Eigen::MatrixXd V;
  Eigen::MatrixXi F;
  create_unit_cube_mesh(V, F);
  auto geom = make_triangle_mesh(V, F);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test different DoF configurations
  std::vector<Eigen::VectorXd> test_dofs = {
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.1, 0.2, 0.3, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1)).finished(),
  };
  
  // Test a selection of k-vectors
  std::vector<Eigen::Vector3d> test_k_vectors = {
    Eigen::Vector3d(0.5, 0.0, 0.0),
    Eigen::Vector3d(1.0, 0.0, 0.0),
    Eigen::Vector3d(0.0, 1.0, 0.0),
    Eigen::Vector3d(1.0, 1.0, 0.0),
  };
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& dofs : test_dofs) {
    for (const auto& k : test_k_vectors) {
      // Compute gradient using CUDA
      Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
      
      // Compute gradient using CPU
      Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
      
      // Compare
      for (int i = 0; i < grad_cuda.size(); ++i) {
        std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(grad_cuda(i));
        double abs_cpu = std::abs(grad_cpu(i));
        double max_abs = std::max(abs_cuda, abs_cpu);
        
        // Use absolute error if either value is very small, or if relative error would be misleading
        bool use_absolute = (max_abs < 1e-6);
        double error;
        if (use_absolute) {
          // For near-zero values, use absolute error normalized by 1e-5 threshold
          // This allows errors up to 1e-5 to pass (normalized error = 1.0)
          error = abs_error / 1e-5;
        } else {
          // For non-zero values, use relative error
          error = abs_error / max_abs;
        }
        
        if (error > max_error) max_error = error;
        
        // Only warn for errors that would cause test failure (error > 1.0)
        if (error > 1.0 && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for DoF " << i << std::endl;
          std::cout << "    k = (" << k.x() << ", " << k.y() << ", " << k.z() << ")" << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << std::endl;
          std::cout << "    CPU:  " << grad_cpu(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << " (normalized: " << error << ", threshold: 1e-5)" << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  
  // For near-zero values (|value| < 1e-6), we use normalized absolute error (error / 1e-5)
  //   This allows absolute errors up to 1e-5 to pass
  // For non-zero values, we use relative error
  //   This allows relative errors up to 50% to pass
  // Overall threshold: allow up to 1.0 (either 1e-5 absolute error or 100% relative error)
  bool passed = max_error < 1.0;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 2 Advanced: Test ∂A(k)/∂θ computation over entire KGrid
// ============================================================================

bool test_phase2_Ak_gradient_computation_advanced(const std::string& leb_file) {
  std::cout << "\n=== Phase 2 Advanced Test: ∂A(k)/∂θ Computation (Full KGrid) ===" << std::endl;
  
  // Create unit cube mesh
  Eigen::MatrixXd V;
  Eigen::MatrixXi F;
  create_unit_cube_mesh(V, F);
  auto geom = make_triangle_mesh(V, F);
  
  // Create AffineDoF
  auto affine_dof = std::make_shared<AffineDoF>();
  
  // Test DoF configuration (identity transformation)
  Eigen::VectorXd dofs(12);
  dofs << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load small Lebedev grid and build KGrid
  // Try to use lebedev_005.txt if available, otherwise use the provided file
  std::string small_leb_file = leb_file;
  size_t last_slash = leb_file.find_last_of("/\\");
  if (last_slash != std::string::npos) {
    std::string dir = leb_file.substr(0, last_slash + 1);
    small_leb_file = dir + "lebedev_005.txt";
  } else {
    // Try to use default path structure
#ifdef POINTINT_SOURCE_DIR
    std::string source_dir = POINTINT_SOURCE_DIR;
    // Convert backslashes to forward slashes
    for (size_t i = 0; i < source_dir.length(); ++i) {
      if (source_dir[i] == '\\') source_dir[i] = '/';
    }
    small_leb_file = source_dir + "/data/lebedev/lebedev_005.txt";
#else
    small_leb_file = "lebedev_005.txt";
#endif
  }
  
  LebedevGrid L;
  try {
    L = load_lebedev_txt(small_leb_file);
    std::cout << "  Using Lebedev file: " << small_leb_file << std::endl;
  } catch (...) {
    // If lebedev_005.txt not found, try to use the provided file
    std::cout << "  Note: Could not load lebedev_005.txt, using provided file instead" << std::endl;
    L = load_lebedev_txt(leb_file);
  }
  
  int nRad = 4;
  KGrid KG = build_kgrid(L.dirs, L.weights, nRad);
  int Q = KG.dirs.size();
  
  std::cout << "  Using KGrid with " << Q << " k-nodes (Lebedev: " << L.dirs.size() 
            << " directions, Radial: " << nRad << " points)" << std::endl;
  
  double max_error = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  int num_failed = 0;
  
  // Test over all k-vectors in the KGrid
  for (int q = 0; q < Q; ++q) {
    // Construct k-vector from KGrid
    Eigen::Vector3d k(
      KG.dirs[q][0] * KG.kmag[q],
      KG.dirs[q][1] * KG.kmag[q],
      KG.dirs[q][2] * KG.kmag[q]
    );
    
    // Compute gradient using CUDA
    Eigen::VectorXcd grad_cuda = compute_Ak_gradient_cuda(geom, k, affine_dof, dofs, 256);
    
    // Compute gradient using CPU
    Eigen::VectorXcd grad_cpu = affine_dof->compute_A_gradient(geom, k, dofs);
    
    // Compare each DoF component
    for (int i = 0; i < grad_cuda.size(); ++i) {
      std::complex<double> diff = grad_cuda(i) - grad_cpu(i);
      double abs_error = std::abs(diff);
      double abs_cuda = std::abs(grad_cuda(i));
      double abs_cpu = std::abs(grad_cpu(i));
      double max_abs = std::max(abs_cuda, abs_cpu);
      double min_abs = std::min(abs_cuda, abs_cpu);
      
      // Use absolute error if both values are very small, or if one is near zero
      // This handles cases where one value is essentially zero and the other is small
      bool use_absolute = (max_abs < 1e-4) || (min_abs < 1e-10 && max_abs < 1e-4);
      double error;
      if (use_absolute) {
        // For near-zero values, use absolute error normalized by 1e-4 threshold
        // This is more lenient than 1e-5 to account for numerical precision differences
        error = abs_error / 1e-4;
      } else {
        // For non-zero values, use relative error
        error = abs_error / max_abs;
      }
      
      if (error > max_error) max_error = error;
      
      // Track failures (error > 2.0 for absolute, > 0.1 for relative)
      // More lenient thresholds for this comprehensive test
      double failure_threshold = use_absolute ? 2.0 : 0.1;
      if (error > failure_threshold) {
        num_failed++;
        // Only print warnings for first few failures to avoid spam
        if (num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for k-node " << q << ", DoF " << i << std::endl;
          std::cout << "    k = (" << k.x() << ", " << k.y() << ", " << k.z() << "), |k| = " << k.norm() << std::endl;
          std::cout << "    CUDA: " << grad_cuda(i) << std::endl;
          std::cout << "    CPU:  " << grad_cpu(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << " (normalized: " << error << ", threshold: 1e-4)" << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
      }
      
      num_tested++;
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components over " << Q << " k-nodes" << std::endl;
  std::cout << "  Max error: " << max_error << std::endl;
  std::cout << "  Failed components: " << num_failed << " / " << num_tested 
            << " (" << (100.0 * num_failed / num_tested) << "%)" << std::endl;
  
  // Pass if failure rate is low (< 5%)
  // For this comprehensive test, we're more lenient since we're testing many edge cases
  // The max error threshold is handled per-component above
  bool passed = (num_failed < 0.05 * num_tested);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Phase 3: Test intersection volume gradient (existing test)
// ============================================================================

// Compute gradient of intersection volume using finite differencing
Eigen::VectorXd compute_intersection_volume_gradient_finite_diff(
  const Geometry& geom1,
  const Geometry& geom2,
  const std::shared_ptr<DoFParameterization>& dof1,
  const std::shared_ptr<DoFParameterization>& dof2,
  const Eigen::VectorXd& dofs1,
  const Eigen::VectorXd& dofs2,
  const KGrid& kgrid,
  int which_geometry,  // 1 for geom1, 2 for geom2
  double eps = 1e-2)
{
  int n_dofs = (which_geometry == 1) ? dof1->num_dofs() : dof2->num_dofs();
  Eigen::VectorXd grad(n_dofs);
  
  for (int i = 0; i < n_dofs; ++i) {
    // 5-point finite difference for better accuracy
    Eigen::VectorXd dofs1_plus = dofs1;
    Eigen::VectorXd dofs2_plus = dofs2;
    Eigen::VectorXd dofs1_minus = dofs1;
    Eigen::VectorXd dofs2_minus = dofs2;
    
    if (which_geometry == 1) {
      dofs1_plus(i) += 2.0 * eps;
      dofs1_minus(i) -= 2.0 * eps;
    } else {
      dofs2_plus(i) += 2.0 * eps;
      dofs2_minus(i) -= 2.0 * eps;
    }
    
    // Compute volumes at perturbed DoFs
    Geometry geom1_p2 = dof1->apply(geom1, dofs1_plus);
    Geometry geom2_p2 = dof2->apply(geom2, dofs2_plus);
    double vol_p2 = compute_intersection_volume_cuda(geom1_p2, geom2_p2, kgrid, 256, false);
    
    if (which_geometry == 1) {
      dofs1_plus(i) -= eps;
      dofs1_minus(i) += eps;
    } else {
      dofs2_plus(i) -= eps;
      dofs2_minus(i) += eps;
    }
    
    Geometry geom1_p1 = dof1->apply(geom1, dofs1_plus);
    Geometry geom2_p1 = dof2->apply(geom2, dofs2_plus);
    double vol_p1 = compute_intersection_volume_cuda(geom1_p1, geom2_p1, kgrid, 256, false);
    
    Geometry geom1_m1 = dof1->apply(geom1, dofs1_minus);
    Geometry geom2_m1 = dof2->apply(geom2, dofs2_minus);
    double vol_m1 = compute_intersection_volume_cuda(geom1_m1, geom2_m1, kgrid, 256, false);
    
    if (which_geometry == 1) {
      dofs1_minus(i) -= eps;
    } else {
      dofs2_minus(i) -= eps;
    }
    
    Geometry geom1_m2 = dof1->apply(geom1, dofs1_minus);
    Geometry geom2_m2 = dof2->apply(geom2, dofs2_minus);
    double vol_m2 = compute_intersection_volume_cuda(geom1_m2, geom2_m2, kgrid, 256, false);
    
    // 5-point finite difference: (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)) / (12h)
    grad(i) = (-vol_p2 + 8.0 * vol_p1 - 8.0 * vol_m1 + vol_m2) / (12.0 * eps);
  }
  
  return grad;
}

// ============================================================================
// Test 1: Intersection Volume Gradient for AffineDoF (Triangle Meshes)
// ============================================================================
bool test_intersection_volume_gradient_affine(const std::string& leb_file) {
  std::cout << "\n=== Test 1: Intersection Volume Gradient (AffineDoF, Triangle Meshes) ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  Eigen::Vector3d translation(0.3, 0.0, 0.0);
  for (int i = 0; i < V2.rows(); ++i) {
    V2.row(i) += translation;
  }
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Test DoF configurations
  std::vector<Eigen::VectorXd> test_dofs1 = {
    // Identity: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1]
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    // Small translation: [0.1, 0.0, 0.0, 1, 0, 0, 0, 1, 0, 0, 0, 1]
    (Eigen::VectorXd(12) << 0.1, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    // Rotation around z-axis: [0, 0, 0, cos(0.1), -sin(0.1), 0, sin(0.1), cos(0.1), 0, 0, 0, 1]
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, std::cos(0.1), -std::sin(0.1), 0.0, std::sin(0.1), std::cos(0.1), 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  std::vector<Eigen::VectorXd> test_dofs2 = {
    // Identity
    (Eigen::VectorXd(12) << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
    // Small translation
    (Eigen::VectorXd(12) << 0.0, 0.1, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0).finished(),
  };
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 1);
  
  double max_error_geom1 = 0.0;
  double max_error_geom2 = 0.0;
  int num_tested = 0;
  int num_warnings = 0;
  
  for (const auto& dofs1 : test_dofs1) {
    for (const auto& dofs2 : test_dofs2) {
      // Compute gradient using CUDA
      auto result = compute_intersection_volume_gradient_cuda(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 256, false
      );
      
      // Compute gradient using finite differencing
      Eigen::VectorXd grad_fd1 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 1, 1e-4
      );
      
      Eigen::VectorXd grad_fd2 = compute_intersection_volume_gradient_finite_diff(
        geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 2, 1e-4
      );
      
      // Compare gradients for geometry 1
      for (int i = 0; i < result.grad_geom1.size(); ++i) {
        double diff = result.grad_geom1(i) - grad_fd1(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(result.grad_geom1(i));
        double abs_fd = std::abs(grad_fd1(i));
        
        // Use absolute error if both are near zero, otherwise use relative error
        bool use_absolute = (abs_cuda < 1e-8 && abs_fd < 1e-8);
        double error = use_absolute ? abs_error : (abs_error / std::max(abs_cuda, abs_fd));
        
        if (error > max_error_geom1) {
          max_error_geom1 = error;
        }
        
        double tolerance = use_absolute ? 1e-3 : 0.1;  // 10% relative or 1e-3 absolute
        if (error > tolerance && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for geom1 DoF " << i << std::endl;
          std::cout << "    CUDA:     " << result.grad_geom1(i) << std::endl;
          std::cout << "    Finite:   " << grad_fd1(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
      
      // Compare gradients for geometry 2
      for (int i = 0; i < result.grad_geom2.size(); ++i) {
        double diff = result.grad_geom2(i) - grad_fd2(i);
        double abs_error = std::abs(diff);
        double abs_cuda = std::abs(result.grad_geom2(i));
        double abs_fd = std::abs(grad_fd2(i));
        
        // Use absolute error if both are near zero, otherwise use relative error
        bool use_absolute = (abs_cuda < 1e-8 && abs_fd < 1e-8);
        double error = use_absolute ? abs_error : (abs_error / std::max(abs_cuda, abs_fd));
        
        if (error > max_error_geom2) {
          max_error_geom2 = error;
        }
        
        double tolerance = use_absolute ? 1e-3 : 0.1;  // 10% relative or 1e-3 absolute
        if (error > tolerance && num_warnings < 10) {
          std::cout << "  Warning: Large gradient error for geom2 DoF " << i << std::endl;
          std::cout << "    CUDA:     " << result.grad_geom2(i) << std::endl;
          std::cout << "    Finite:   " << grad_fd2(i) << std::endl;
          if (use_absolute) {
            std::cout << "    Abs error: " << abs_error << std::endl;
          } else {
            std::cout << "    Rel error: " << error << std::endl;
          }
          num_warnings++;
        }
        
        num_tested++;
      }
    }
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max error (geom1): " << max_error_geom1 << std::endl;
  std::cout << "  Max error (geom2): " << max_error_geom2 << std::endl;
  
  // Pass if max error is reasonable (10% relative or 1e-3 absolute)
  bool passed = (max_error_geom1 < 0.2) && (max_error_geom2 < 0.2);
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Test 2: Intersection Volume Gradient Consistency Check
// ============================================================================
bool test_intersection_volume_gradient_consistency(const std::string& leb_file) {
  std::cout << "\n=== Test 2: Intersection Volume Gradient Consistency ===" << std::endl;
  
  // Create two unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  
  // Base DoFs (identity)
  Eigen::VectorXd dofs1_base(12);
  dofs1_base << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  Eigen::VectorXd dofs2_base(12);
  dofs2_base << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  KGrid KG = build_kgrid(L.dirs, L.weights, 1);
  
  // Compute base volume
  Geometry geom1_base = affine_dof1->apply(geom1, dofs1_base);
  Geometry geom2_base = affine_dof2->apply(geom2, dofs2_base);
  double vol_base = compute_intersection_volume_cuda(geom1_base, geom2_base, KG, 256, false);
  
  // Compute gradient
  auto result = compute_intersection_volume_gradient_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1_base, dofs2_base, KG, 256, false
  );
  
  // Perturb DoFs and check volume change
  double eps = 1e-3;
  double max_relative_error = 0.0;
  int num_tested = 0;
  
  // Test geometry 1 gradients
  for (int i = 0; i < result.grad_geom1.size(); ++i) {
    Eigen::VectorXd dofs1_pert = dofs1_base;
    dofs1_pert(i) += eps;
    
    Geometry geom1_pert = affine_dof1->apply(geom1, dofs1_pert);
    double vol_pert = compute_intersection_volume_cuda(geom1_pert, geom2_base, KG, 256, false);
    
    double vol_change = vol_pert - vol_base;
    double predicted_change = result.grad_geom1(i) * eps;
    
    double error = std::abs(vol_change - predicted_change);
    double rel_error = (std::abs(predicted_change) > 1e-10) ? (error / std::abs(predicted_change)) : error;
    
    if (rel_error > max_relative_error) {
      max_relative_error = rel_error;
    }
    
    num_tested++;
  }
  
  // Test geometry 2 gradients
  for (int i = 0; i < result.grad_geom2.size(); ++i) {
    Eigen::VectorXd dofs2_pert = dofs2_base;
    dofs2_pert(i) += eps;
    
    Geometry geom2_pert = affine_dof2->apply(geom2, dofs2_pert);
    double vol_pert = compute_intersection_volume_cuda(geom1_base, geom2_pert, KG, 256, false);
    
    double vol_change = vol_pert - vol_base;
    double predicted_change = result.grad_geom2(i) * eps;
    
    double error = std::abs(vol_change - predicted_change);
    double rel_error = (std::abs(predicted_change) > 1e-10) ? (error / std::abs(predicted_change)) : error;
    
    if (rel_error > max_relative_error) {
      max_relative_error = rel_error;
    }
    
    num_tested++;
  }
  
  std::cout << "  Tested " << num_tested << " gradient components" << std::endl;
  std::cout << "  Max relative error: " << max_relative_error << std::endl;
  
  // Pass if error is reasonable (20% tolerance for consistency check)
  bool passed = max_relative_error < 0.2;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Test: Compare volume from gradient routine with compute_intersection_volume_cuda
// ============================================================================
bool test_volume_consistency(const std::string& leb_file) {
  std::cout << "\n=== Phase 3 Test 3: Volume Consistency ===" << std::endl;
  
  // Create unit cube meshes
  Eigen::MatrixXd V1, V2;
  Eigen::MatrixXi F1, F2;
  create_unit_cube_mesh(V1, F1);
  create_unit_cube_mesh(V2, F2);
  
  // Translate second cube
  V2.col(0).array() += 0.3;  // Translate in x-direction
  
  auto geom1 = make_triangle_mesh(V1, F1);
  auto geom2 = make_triangle_mesh(V2, F2);
  
  // Create AffineDoF with identity transformations
  auto affine_dof1 = std::make_shared<AffineDoF>();
  auto affine_dof2 = std::make_shared<AffineDoF>();
  Eigen::VectorXd dofs1(12);
  Eigen::VectorXd dofs2(12);
  dofs1 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  dofs2 << 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0;
  
  // Load Lebedev grid and build k-grid
  LebedevGrid L = load_lebedev_txt(leb_file);
  int radial_points = 52;
  KGrid KG = build_kgrid(L.dirs, L.weights, radial_points);
  
  // Compute volume using gradient routine
  auto result = compute_intersection_volume_gradient_cuda(
    geom1, geom2, affine_dof1, affine_dof2, dofs1, dofs2, KG, 256, false
  );
  double volume_from_gradient = result.volume;
  
  // Compute volume using standard routine
  Geometry geom1_transformed = affine_dof1->apply(geom1, dofs1);
  Geometry geom2_transformed = affine_dof2->apply(geom2, dofs2);
  double volume_from_standard = compute_intersection_volume_cuda(
    geom1_transformed, geom2_transformed, KG, 256, false
  );
  
  // Compare
  double error = std::abs(volume_from_gradient - volume_from_standard);
  double rel_error = (std::abs(volume_from_standard) > 1e-10) 
    ? (error / std::abs(volume_from_standard)) 
    : error;
  
  std::cout << "  Volume from gradient routine: " << std::scientific << std::setprecision(10) 
            << volume_from_gradient << std::endl;
  std::cout << "  Volume from standard routine: " << volume_from_standard << std::endl;
  std::cout << "  Absolute error: " << error << std::endl;
  std::cout << "  Relative error: " << std::fixed << std::setprecision(6) 
            << rel_error * 100.0 << "%" << std::endl;
  
  // Pass if relative error is small (< 1%)
  bool passed = rel_error < 0.01;
  std::cout << "  Result: " << (passed ? "PASS" : "FAIL") << std::endl;
  
  return passed;
}

// ============================================================================
// Main
// ============================================================================
int main(int argc, char* argv[]) {
  // Get Lebedev file path from command line or use default
  std::string leb_file;
  if (argc >= 2) {
    leb_file = argv[1];
  } else {
    leb_file = get_default_lebedev_path();
  }
  
  std::cout << "Running unit tests for intersection volume gradient computation..." << std::endl;
  std::cout << "Lebedev file: " << leb_file << std::endl;
  
  // Clear any previous CUDA errors
  cudaError_t err = cudaGetLastError();
  if (err != cudaSuccess && err != cudaErrorNoDevice) {
    cudaDeviceSynchronize();  // Clear error state
  }
  
  bool all_passed = true;
  
  // Phase 1: Test A(k) computation
  bool phase1_passed = test_phase1_Ak_computation();
  all_passed = all_passed && phase1_passed;
  if (!phase1_passed) {
    std::cout << "\nPhase 1 FAILED! Skipping subsequent tests." << std::endl;
    return 1;
  }
  
  // Phase 2: Test ∂A(k)/∂θ computation
  bool phase2_passed = test_phase2_Ak_gradient_computation();
  all_passed = all_passed && phase2_passed;
  if (!phase2_passed) {
    std::cout << "\nPhase 2 FAILED! Skipping subsequent tests." << std::endl;
    return 1;
  }
  
  // Phase 2 Advanced: Test ∂A(k)/∂θ computation over entire KGrid
  bool phase2_advanced_passed = test_phase2_Ak_gradient_computation_advanced(leb_file);
  all_passed = all_passed && phase2_advanced_passed;
  
  // Phase 3: Test intersection volume gradient (full pipeline)
  // Test 1: Finite difference comparison
  bool test1_passed = test_intersection_volume_gradient_affine(leb_file);
  all_passed = all_passed && test1_passed;
  
  // Test 2: Consistency check
  bool test2_passed = test_intersection_volume_gradient_consistency(leb_file);
  all_passed = all_passed && test2_passed;
  
  // Test 3: Volume consistency
  bool test3_passed = test_volume_consistency(leb_file);
  all_passed = all_passed && test3_passed;
  
  // Summary
  std::cout << "\n=== Summary ===" << std::endl;
  std::cout << "Phase 1 (A(k) computation):           " << (phase1_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "Phase 2 (∂A(k)/∂θ computation):        " << (phase2_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "Phase 2 Advanced (Full KGrid):         " << (phase2_advanced_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "Phase 3 Test 1 (Finite Difference):  " << (test1_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "Phase 3 Test 2 (Consistency):         " << (test2_passed ? "PASS" : "FAIL") << std::endl;
  std::cout << "Phase 3 Test 3 (Volume Consistency):  " << (test3_passed ? "PASS" : "FAIL") << std::endl;
  
  if (all_passed) {
    std::cout << "\nAll tests PASSED!" << std::endl;
    return 0;
  } else {
    std::cout << "\nSome tests FAILED!" << std::endl;
    return 1;
  }
}

